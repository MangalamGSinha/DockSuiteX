{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DockSuiteX","text":"<p>All-in-one Protein-Ligand Docking Package</p> <p>DockSuiteX is a comprehensive Python package for molecular docking that integrates multiple tools including MGLTools, P2Rank, AutoDock Vina, and AutoDock4. It provides a unified, user-friendly interface for protein and ligand preparation, binding pocket prediction, and molecular docking simulations.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Automated Preparation: Streamlined protein and ligand preparation using PDBFixer and Open Babel</li> <li>Pocket Prediction: Binding pocket prediction with P2Rank machine learning</li> <li>Multiple Docking Engines: Support for both AutoDock Vina and AutoDock4</li> <li>Batch Processing: High-throughput screening with parallel execution</li> <li>Interactive Visualization: 3D molecular visualization with NGLView</li> <li>Utility Functions: Built-in tools for fetching structures and parsing results</li> </ul>"},{"location":"#platform-support","title":"Platform Support","text":"<p>Windows Only</p> <p>DockSuiteX currently supports Windows platforms only. The package includes pre-compiled binaries for Windows.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from docksuitex import Protein, Ligand, VinaDocking\n\n# Prepare protein\nprotein = Protein(\"protein.pdb\")\nprotein.prepare(save_to=\"prepared_protein.pdbqt\")\n\n# Prepare ligand\nligand = Ligand(\"ligand.sdf\")\nligand.prepare(save_to=\"prepared_ligand.pdbqt\")\n\n# Run docking\ndocking = VinaDocking(\n    receptor=\"prepared_protein.pdbqt\",\n    ligand=\"prepared_ligand.pdbqt\",\n    grid_center=(10.0, 15.0, 20.0)\n)\nresults = docking.run()\n</code></pre>"},{"location":"#integrated-tools","title":"Integrated Tools","text":"<p>DockSuiteX bundles and integrates the following tools:</p> <ul> <li>MGLTools: Protein and ligand preparation (prepare_receptor4.py, prepare_ligand4.py)</li> <li>AutoDock Vina: Fast gradient-based docking</li> <li>AutoDock4: Classic genetic algorithm-based docking</li> <li>P2Rank: Machine learning pocket prediction</li> <li>Open Babel: Format conversion and energy minimization</li> <li>PDBFixer: Protein structure repair</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out the Installation Guide to get started, or jump straight to the Quick Start Tutorial to see DockSuiteX in action!</p>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Installation, quick start, and examples</li> <li>User Guide: Detailed tutorials for each component</li> <li>API Reference: Complete API documentation with examples</li> <li>About: License, contributing guidelines, and changelog</li> </ul>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#v010","title":"v0.1.0","text":"<ul> <li>Initial release</li> </ul>"},{"location":"about/contributing/","title":"Contributing","text":"<p>We welcome contributions! Please see our GitHub repository for more details.</p>"},{"location":"about/license/","title":"License","text":"<p>DockSuiteX is released under the MIT License.</p>"},{"location":"api/autodock4/","title":"AD4Docking","text":""},{"location":"api/autodock4/#docksuitex.autodock4.AD4Docking","title":"docksuitex.autodock4.AD4Docking","text":"<pre><code>AD4Docking(\n    receptor: Union[str, Path, Protein],\n    ligand: Union[str, Path, Ligand],\n    grid_center: tuple[float, float, float],\n    grid_size: tuple[int, int, int] = (60, 60, 60),\n    spacing: float = 0.375,\n    dielectric: float = -0.1465,\n    smooth: float = 0.5,\n    ga_pop_size: int = 150,\n    ga_num_evals: int = 2500000,\n    ga_num_generations: int = 27000,\n    ga_elitism: int = 1,\n    ga_mutation_rate: float = 0.02,\n    ga_crossover_rate: float = 0.8,\n    ga_run: int = 10,\n    rmstol: float = 2.0,\n    seed: tuple[Union[int, str], Union[int, str]] = (\n        \"pid\",\n        \"time\",\n    ),\n)\n</code></pre> <p>A Python wrapper for AutoDock4 and AutoGrid to automate receptor\u2013ligand docking.</p> <p>This class automates receptor\u2013ligand docking using AutoDock4. It prepares grid parameter (GPF) and docking parameter (DPF) files, runs AutoGrid and AutoDock, and saves docking results.</p> <p>Initialize an AutoDock4 docking run.</p>"},{"location":"api/autodock4/#docksuitex.autodock4.AD4Docking--parameters","title":"Parameters","text":"<p>receptor : str | Path     Path to the receptor PDBQT file. ligand : str | Path     Path to the ligand PDBQT file. grid_center : tuple[float, float, float], default=(0,0,0)     Grid box center coordinates. grid_size : tuple[int, int, int], default=(60,60,60)     Number of points in the grid box. spacing : float, default=0.375     Grid spacing in \u00c5. dielectric : float, default=-0.1465     Dielectric constant for electrostatics. smooth : float, default=0.5     Smoothing factor for potential maps. ga_pop_size : int, default=150     Genetic algorithm population size. ga_num_evals : int, default=2_500_000     Maximum number of energy evaluations in GA. ga_num_generations : int, default=27_000     Maximum number of generations in GA. ga_elitism : int, default=1     Number of top individuals preserved during GA. ga_mutation_rate : float, default=0.02     Probability of mutation in GA. ga_crossover_rate : float, default=0.8     Probability of crossover in GA. ga_run : int, default=10     Number of independent GA runs. rmstol : float, default=2.0     RMSD tolerance for clustering docking results. seed : tuple[int | str, int | str], default=(\"pid\", \"time\")     Each element can be an integer or the keywords \"pid\" or \"time\".</p> Source code in <code>docksuitex\\autodock4.py</code> <pre><code>def __init__(\n    self,\n    receptor: Union[str, Path, \"Protein\"],\n    ligand: Union[str, Path, \"Ligand\"],\n    grid_center: tuple[float, float, float],\n    grid_size: tuple[int, int, int] = (60, 60, 60),\n    spacing: float = 0.375,\n    dielectric: float = -0.1465,\n    smooth: float = 0.5,\n    # Genetic Algorithm Parameters\n    ga_pop_size: int = 150,\n    ga_num_evals: int = 2500000,\n    ga_num_generations: int = 27000,\n    ga_elitism: int = 1,\n    ga_mutation_rate: float = 0.02,\n    ga_crossover_rate: float = 0.8,\n    ga_run: int = 10,\n    rmstol: float = 2.0,\n    seed: tuple[Union[int, str], Union[int, str]] = (\"pid\", \"time\")\n):\n    \"\"\"\n    Initialize an AutoDock4 docking run.\n\n    Parameters\n    ----------\n    receptor : str | Path\n        Path to the receptor PDBQT file.\n    ligand : str | Path\n        Path to the ligand PDBQT file.\n    grid_center : tuple[float, float, float], default=(0,0,0)\n        Grid box center coordinates.\n    grid_size : tuple[int, int, int], default=(60,60,60)\n        Number of points in the grid box.\n    spacing : float, default=0.375\n        Grid spacing in \u00c5.\n    dielectric : float, default=-0.1465\n        Dielectric constant for electrostatics.\n    smooth : float, default=0.5\n        Smoothing factor for potential maps.\n    ga_pop_size : int, default=150\n        Genetic algorithm population size.\n    ga_num_evals : int, default=2_500_000\n        Maximum number of energy evaluations in GA.\n    ga_num_generations : int, default=27_000\n        Maximum number of generations in GA.\n    ga_elitism : int, default=1\n        Number of top individuals preserved during GA.\n    ga_mutation_rate : float, default=0.02\n        Probability of mutation in GA.\n    ga_crossover_rate : float, default=0.8\n        Probability of crossover in GA.\n    ga_run : int, default=10\n        Number of independent GA runs.\n    rmstol : float, default=2.0\n        RMSD tolerance for clustering docking results.\n    seed : tuple[int | str, int | str], default=(\"pid\", \"time\")\n        Each element can be an integer or the keywords \"pid\" or \"time\".\n    \"\"\"\n    # normalize receptor\n\n    self.receptor = Path(receptor).resolve()\n    self.ligand = Path(ligand).resolve()\n\n    if not self.receptor.is_file():\n        raise FileNotFoundError(\n            f\"\u274c Receptor file not found: {self.receptor}\")\n    if not self.ligand.is_file():\n        raise FileNotFoundError(f\"\u274c Ligand file not found: {self.ligand}\")\n\n    if self.receptor.suffix.lower() != \".pdbqt\":\n        raise ValueError(\"\u26a0\ufe0f Receptor must be a .pdbqt file.\")\n    if self.ligand.suffix.lower() != \".pdbqt\":\n        raise ValueError(\"\u26a0\ufe0f Ligand must be a .pdbqt file.\")\n\n\n    if not (isinstance(grid_center, tuple) and len(grid_center) == 3):\n        raise ValueError(\"\u26a0\ufe0f 'grid_center' must be a 3-tuple of floats.\")\n    if not (isinstance(grid_size, tuple) and len(grid_size) == 3):\n        raise ValueError(\"\u26a0\ufe0f 'grid_size' must be a 3-tuple of floats.\")\n    if any(not isinstance(v, (float, int)) for v in grid_center + grid_size):\n        raise TypeError(\n            \"\u26a0\ufe0f Grid grid_center and grid_size values must be float or int.\")\n\n\n\n    # Grid parameters\n    self.grid_center = grid_center\n    self.grid_size = grid_size\n    self.spacing = spacing\n    self.dielectric = dielectric\n    self.smooth = smooth\n\n    # Docking parameters\n    self.ga_pop_size = ga_pop_size\n    self.ga_num_evals = ga_num_evals\n    self.ga_num_generations = ga_num_generations\n    self.ga_elitism = ga_elitism\n    self.ga_mutation_rate = ga_mutation_rate\n    self.ga_crossover_rate = ga_crossover_rate\n    self.ga_run = ga_run\n    self.rmstol = rmstol\n    self.seed = seed\n</code></pre>"},{"location":"api/autodock4/#docksuitex.autodock4.AD4Docking.run","title":"run","text":"<pre><code>run(save_to: Union[str, Path] = None) -&gt; Path\n</code></pre> <p>Runs AutoGrid and AutoDock for molecular docking.</p> <p>RuntimeError: If AutoGrid or AutoDock fails, or expected output     files (.fld or .dlg) are missing.</p> Source code in <code>docksuitex\\autodock4.py</code> <pre><code>def run(self, save_to: Union[str, Path] = None) -&gt; Path:\n    \"\"\"\n    Runs AutoGrid and AutoDock for molecular docking.\n\n    Raises:\n    RuntimeError: If AutoGrid or AutoDock fails, or expected output\n        files (.fld or .dlg) are missing.\n    \"\"\"\n    self._setup_environment()\n\n    if save_to is None:\n        save_to = f\"ad4_docked_{self.receptor.stem}_{self.ligand.stem}\"\n    self.output_dir = Path(save_to).resolve()\n    self.output_dir.mkdir(parents=True, exist_ok=True)\n\n    shutil.copy2(self.receptor, self.output_dir / self.receptor.name)\n    shutil.copy2(self.ligand, self.output_dir / self.ligand.name)\n\n    self.receptor = self.output_dir / self.receptor.name\n    self.ligand = self.output_dir / self.ligand.name\n\n    self.gpf_file = self.output_dir / \"receptor.gpf\"\n    self.glg_file = self.output_dir / \"receptor.glg\"\n    self.dpf_file = self.output_dir / \"ligand.dpf\"\n    self.dlg_file = self.output_dir / \"results.dlg\"\n\n    self.receptor_types = self._detect_atom_types(self.receptor)\n    self.ligand_types = self._detect_atom_types(self.ligand)\n\n\n    # Run AutoGrid\n    self._create_gpf()\n    autogrid_cmd = [str(AUTOGRID_EXE), \"-p\", str(self.gpf_file.name), \"-l\", str(self.glg_file.name)]\n    result = subprocess.run(\n        autogrid_cmd,\n        cwd=str(self.output_dir),\n        capture_output=True,\n        text=True,\n    )\n    if result.returncode != 0:\n        if self.glg_file.exists():\n            raise RuntimeError(f\"\u274c AutoGrid failed. Log file content:\\n{self.glg_file.read_text()}\")\n        raise subprocess.CalledProcessError(result.returncode, autogrid_cmd, result.stdout, result.stderr)\n\n    fld_file = self.output_dir / \"receptor.maps.fld\"\n    if not fld_file.exists():\n        raise RuntimeError(\"\u274c AutoGrid did not create the .fld file\")\n\n    # Run AutoDock\n    self._create_dpf()\n    autodock_cmd = [str(AUTODOCK_EXE), \"-p\", str(self.dpf_file.name), \"-l\", str(self.dlg_file.name)]\n    result = subprocess.run(\n        autodock_cmd,\n        cwd=str(self.output_dir),\n        capture_output=True,\n        text=True,\n    )\n\n    if result.returncode != 0:\n        if self.dlg_file.exists():\n            raise RuntimeError(f\"\u274c AutoDock failed. Log file content:\\n{self.dlg_file.read_text()}\")\n        raise subprocess.CalledProcessError(result.returncode, autodock_cmd, result.stdout, result.stderr)\n\n    if not self.dlg_file.exists():\n        raise RuntimeError(\"\u274c Docking results are missing\")\n\n    self._extract_lowest_energy_conformations(self.dlg_file, Path(self.output_dir / \"output.pdbqt\"))\n\n    print(f\"\u2705 AutoDock4 completed. Results saved to: {self.output_dir}\")\n    return self.output_dir\n</code></pre>"},{"location":"api/autodock4/#docksuitex.autodock4.AD4Docking.view_results","title":"view_results","text":"<pre><code>view_results()\n</code></pre> <p>Visualize docking results using NGLView.</p> <p>Opens the receptor and docked ligand in an interactive 3D widget inside a Jupyter notebook.</p> <p>Returns:</p> Type Description <p>nglview.NGLWidget: Interactive visualization of receptor\u2013ligand complex.</p> Source code in <code>docksuitex\\autodock4.py</code> <pre><code>def view_results(self):\n    \"\"\"\n    Visualize docking results using NGLView.\n\n    Opens the receptor and docked ligand in an interactive\n    3D widget inside a Jupyter notebook.\n\n    Returns:\n        nglview.NGLWidget: Interactive visualization of receptor\u2013ligand complex.\n    \"\"\"\n    view_results(protein_file=self.receptor, ligand_file=Path(self.output_dir / \"output.pdbqt\"))\n</code></pre>"},{"location":"api/batch-autodock4/","title":"BatchAD4Docking","text":""},{"location":"api/batch-autodock4/#docksuitex.batch_docking.batch_autodock4.BatchAD4Docking","title":"docksuitex.batch_docking.batch_autodock4.BatchAD4Docking","text":"<pre><code>BatchAD4Docking(\n    receptors_with_centers: Dict[\n        Union[str, Path],\n        Sequence[tuple[float, float, float]],\n    ],\n    ligands: Union[Sequence[Union[str, Path]], str, Path],\n    grid_size: tuple[int, int, int] = (60, 60, 60),\n    spacing: float = 0.375,\n    dielectric: float = -0.1465,\n    smooth: float = 0.5,\n    ga_pop_size: int = 150,\n    ga_num_evals: int = 2500000,\n    ga_num_generations: int = 27000,\n    ga_elitism: int = 1,\n    ga_mutation_rate: float = 0.02,\n    ga_crossover_rate: float = 0.8,\n    ga_run: int = 10,\n    rmstol: float = 2.0,\n    seed: tuple[Union[int, str], Union[int, str]] = (\n        \"pid\",\n        \"time\",\n    ),\n)\n</code></pre> <p>Batch docking manager for AutoDock4.</p> <p>Runs AutoDock4 docking for multiple ligands against multiple proteins, each with its own set of binding pocket centers, in parallel using a process pool.</p> <p>Initialize a batch docking job.</p> <p>Parameters:</p> Name Type Description Default <code>receptors_with_centers</code> <code>Dict[str | Path, Sequence[tuple[float, float, float]]]</code> <p>Dictionary mapping receptor PDBQT files to their list of binding pocket centers.</p> required <code>ligands</code> <code>Sequence[str | Path]</code> <p>List of ligand PDBQT files.</p> required <code>grid_size</code> <code>tuple[int, int, int]</code> <p>Number of grid points per axis. Defaults to (60, 60, 60).</p> <code>(60, 60, 60)</code> <code>spacing</code> <code>float</code> <p>Grid spacing in \u00c5. Defaults to 0.375.</p> <code>0.375</code> <code>dielectric</code> <code>float</code> <p>Dielectric constant. Defaults to -0.1465.</p> <code>-0.1465</code> <code>smooth</code> <code>float</code> <p>Smoothing factor for potential maps. Defaults to 0.5.</p> <code>0.5</code> <code>ga_pop_size</code> <code>int</code> <p>Genetic algorithm population size. Defaults to 150.</p> <code>150</code> <code>ga_num_evals</code> <code>int</code> <p>Max energy evaluations. Defaults to 2,500,000.</p> <code>2500000</code> <code>ga_num_generations</code> <code>int</code> <p>Max generations. Defaults to 27,000.</p> <code>27000</code> <code>ga_elitism</code> <code>int</code> <p>Elite individuals preserved. Defaults to 1.</p> <code>1</code> <code>ga_mutation_rate</code> <code>float</code> <p>GA mutation rate. Defaults to 0.02.</p> <code>0.02</code> <code>ga_crossover_rate</code> <code>float</code> <p>GA crossover rate. Defaults to 0.8.</p> <code>0.8</code> <code>ga_run</code> <code>int</code> <p>Independent GA runs. Defaults to 10.</p> <code>10</code> <code>rmstol</code> <code>float</code> <p>RMSD tolerance for clustering. Defaults to 2.0.</p> <code>2.0</code> <code>seed</code> <code>tuple[int | str, int | str]</code> <p>Random seed for docking.  Each element can be an integer or the keywords \"pid\" or \"time\".</p> <code>('pid', 'time')</code> Source code in <code>docksuitex\\batch_docking\\batch_autodock4.py</code> <pre><code>def __init__(\n    self,\n    receptors_with_centers: Dict[Union[str, Path], Sequence[tuple[float, float, float]]],\n    ligands: Union[Sequence[Union[str, Path]], str, Path],\n    grid_size: tuple[int, int, int] = (60, 60, 60),\n    spacing: float = 0.375,\n    dielectric: float = -0.1465,\n    smooth: float = 0.5,\n    ga_pop_size: int = 150,\n    ga_num_evals: int = 2_500_000,\n    ga_num_generations: int = 27_000,\n    ga_elitism: int = 1,\n    ga_mutation_rate: float = 0.02,\n    ga_crossover_rate: float = 0.8,\n    ga_run: int = 10,\n    rmstol: float = 2.0,\n    seed: tuple[Union[int, str], Union[int, str]] = (\"pid\", \"time\")\n):\n    \"\"\"Initialize a batch docking job.\n\n    Args:\n        receptors_with_centers (Dict[str | Path, Sequence[tuple[float, float, float]]]): \n            Dictionary mapping receptor PDBQT files to their list of binding pocket centers.\n        ligands (Sequence[str | Path]): List of ligand PDBQT files.\n        grid_size (tuple[int, int, int], optional): Number of grid points per axis. Defaults to (60, 60, 60).\n        spacing (float, optional): Grid spacing in \u00c5. Defaults to 0.375.\n        dielectric (float, optional): Dielectric constant. Defaults to -0.1465.\n        smooth (float, optional): Smoothing factor for potential maps. Defaults to 0.5.\n        ga_pop_size (int, optional): Genetic algorithm population size. Defaults to 150.\n        ga_num_evals (int, optional): Max energy evaluations. Defaults to 2,500,000.\n        ga_num_generations (int, optional): Max generations. Defaults to 27,000.\n        ga_elitism (int, optional): Elite individuals preserved. Defaults to 1.\n        ga_mutation_rate (float, optional): GA mutation rate. Defaults to 0.02.\n        ga_crossover_rate (float, optional): GA crossover rate. Defaults to 0.8.\n        ga_run (int, optional): Independent GA runs. Defaults to 10.\n        rmstol (float, optional): RMSD tolerance for clustering. Defaults to 2.0.\n        seed (tuple[int | str, int | str], optional): Random seed for docking. \n            Each element can be an integer or the keywords \"pid\" or \"time\".\n    \"\"\"\n    self.receptors = receptors_with_centers\n\n    # Handle ligands input\n    if isinstance(ligands, (str, Path)):\n        path = Path(ligands).resolve()\n        if path.is_dir():\n            self.ligands = list(path.glob(\"*.pdbqt\"))\n        elif path.is_file():\n            if path.suffix.lower() == \".pdbqt\":\n                self.ligands = [path]\n            else:\n                raise ValueError(f\"\u274c Invalid ligand file type: {path.suffix}. Must be .pdbqt\")\n        else:\n             raise ValueError(f\"\u274c Ligand input path does not exist: {ligands}\")\n    elif isinstance(ligands, list):\n        self.ligands = [Path(l).expanduser().resolve() for l in ligands]\n    else:\n        raise ValueError(\"\u274c Invalid ligands input. Provide a list of files, a directory path, or a single file path.\")\n\n    if not self.ligands:\n        raise ValueError(\"\u274c No valid ligand PDBQT files found.\")\n\n    self.grid_size = grid_size\n    self.spacing = spacing\n    self.dielectric = dielectric\n    self.smooth = smooth\n    self.ga_pop_size = ga_pop_size\n    self.ga_num_evals = ga_num_evals\n    self.ga_num_generations = ga_num_generations\n    self.ga_elitism = ga_elitism\n    self.ga_mutation_rate = ga_mutation_rate\n    self.ga_crossover_rate = ga_crossover_rate\n    self.ga_run = ga_run\n    self.rmstol = rmstol\n    self.seed = seed\n    self.results: dict[tuple[str, str, tuple[float, float, float]], Union[Path, str]] = {}\n</code></pre>"},{"location":"api/batch-autodock4/#docksuitex.batch_docking.batch_autodock4.BatchAD4Docking.run_all","title":"run_all","text":"<pre><code>run_all(\n    cpu: int = os.cpu_count() or 1,\n    save_to: Union[str, Path] = \"./batch_ad4_results\",\n) -&gt; dict[\n    tuple[str, str, tuple[float, float, float]],\n    Union[Path, str],\n]\n</code></pre> <p>Run AutoDock4 docking for all ligands \u00d7 all centers \u00d7 all receptors in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int</code> <p>Total number of CPU cores to use. Defaults to all available cores. Each worker uses 1 CPU (AutoDock4 is single-threaded).</p> <code>cpu_count() or 1</code> <code>save_to</code> <code>str | Path</code> <p>Directory where results are stored.  Defaults to \"./batch_ad4_results\".</p> <code>'./batch_ad4_results'</code> <p>Returns:</p> Type Description <code>dict[tuple[str, str, tuple[float, float, float]], Union[Path, str]]</code> <p>dict[tuple[str, str, tuple[float, float, float]], Path | str]: Mapping from (receptor_name, ligand_name, center) to: - Path: Path to the docking result directory, if successful. - str: Error message if the docking failed.</p> Source code in <code>docksuitex\\batch_docking\\batch_autodock4.py</code> <pre><code>def run_all(\n    self,\n    cpu: int = os.cpu_count() or 1,\n    save_to: Union[str, Path] = \"./batch_ad4_results\",\n) -&gt; dict[tuple[str, str, tuple[float, float, float]], Union[Path, str]]:\n    \"\"\"Run AutoDock4 docking for all ligands \u00d7 all centers \u00d7 all receptors in parallel.\n\n    Args:\n        cpu (int, optional): Total number of CPU cores to use.\n            Defaults to all available cores. Each worker uses 1 CPU\n            (AutoDock4 is single-threaded).\n        save_to (str | Path, optional): Directory where results are stored. \n            Defaults to \"./batch_ad4_results\".\n\n    Returns:\n        dict[tuple[str, str, tuple[float, float, float]], Path | str]:  \n            Mapping from (receptor_name, ligand_name, center) to:\n            - Path: Path to the docking result directory, if successful.\n            - str: Error message if the docking failed.\n    \"\"\"\n    save_to = Path(save_to).expanduser().resolve()\n    save_to.mkdir(parents=True, exist_ok=True)\n\n    total_tasks = sum(len(self.ligands) * len(centers) for centers in self.receptors.values())\n    max_workers = min(cpu, total_tasks)\n\n    print(f\"Starting AutoDock4 docking for {total_tasks} tasks...\")\n    print(f\"Using {max_workers} parallel workers\")\n    print(f\"Total CPU allocation: {max_workers}\")\n    print(f\"Output directory: {save_to}\")\n\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {}\n        for receptor_path, centers in self.receptors.items():\n            receptor = Path(receptor_path).expanduser().resolve()\n            for center in centers:\n                for lig in self.ligands:\n                    future = executor.submit(self._dock_one, save_to, receptor, lig, center)\n                    futures[future] = (receptor, lig, center)\n\n        for future in as_completed(futures):\n            receptor, lig, center = futures[future]\n            try:\n                rec_name, lig_name, ctr, path = future.result()\n                self.results[(rec_name, lig_name, ctr)] = path\n                center_str = \"_\".join(f\"{c:.2f}\" for c in ctr)\n                print(f\"\u2705 {rec_name} + {lig_name} @ center {center_str} \u2192 saved to {Path(path).name}\")\n            except Exception as e:\n                self.results[(receptor.name, lig.name, center)] = f\"\u274c Failed: {e}\"\n                center_str = \"_\".join(f\"{c:.2f}\" for c in center)\n                print(f\"\u274c {receptor.name} + {lig.name} @ center {center_str} failed. Error: {e}\")\n\n    print(\"Batch processing completed!\")\n    return self.results\n</code></pre>"},{"location":"api/batch-ligand/","title":"BatchLigand","text":""},{"location":"api/batch-ligand/#docksuitex.batch_docking.batch_ligand.BatchLigand","title":"docksuitex.batch_docking.batch_ligand.BatchLigand","text":"<pre><code>BatchLigand(\n    inputs: Union[List[Union[str, Path]], str, Path],\n    minimize: Optional[str] = None,\n    remove_water: bool = True,\n    add_hydrogens: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n)\n</code></pre> <p>Handles batch ligand preparation in parallel.</p> Example <p>batch = BatchLigand(     inputs=\"ligands_folder\",     minimize=\"mmff94\",     remove_water=True,     add_hydrogens=True,     add_charges=True, ) batch.prepare_all(save_to=\"prepared_ligands\")</p> <p>Initialize the batch processor and preparation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>list[str | Path] | str | Path</code> <p>List of ligand files or directory containing ligand files.</p> required <code>minimize, remove_water, add_hydrogens, add_charges</code> <p>Preparation parameters (same as Ligand.prepare()).</p> required <code>preserve_charge_types</code> <code>list[str]</code> <p>Atom types to preserve charges for.</p> <code>None</code> Source code in <code>docksuitex\\batch_docking\\batch_ligand.py</code> <pre><code>def __init__(\n    self,\n    inputs: Union[List[Union[str, Path]], str, Path],\n    minimize: Optional[str] = None,\n    remove_water: bool = True,\n    add_hydrogens: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n):\n    \"\"\"\n    Initialize the batch processor and preparation parameters.\n\n    Args:\n        inputs (list[str | Path] | str | Path): \n            List of ligand files or directory containing ligand files.\n        minimize, remove_water, add_hydrogens, add_charges: \n            Preparation parameters (same as Ligand.prepare()).\n        preserve_charge_types (list[str], optional): Atom types to preserve charges for.\n    \"\"\"\n    # Handle input paths\n    if isinstance(inputs, (str, Path)):\n        path = Path(inputs).resolve()\n        if path.is_dir():\n            self.files = [\n                f.resolve() for f in path.glob(\"*\")\n                if f.suffix.lower().lstrip(\".\") in Ligand.SUPPORTED_INPUTS\n            ]\n        elif path.is_file():\n            if path.suffix.lower().lstrip(\".\") in Ligand.SUPPORTED_INPUTS:\n                self.files = [path]\n            else:\n                raise ValueError(f\"\u274c Invalid file type: {path.suffix}. Supported: {Ligand.SUPPORTED_INPUTS}\")\n        else:\n             raise ValueError(f\"\u274c Input path does not exist: {inputs}\")\n    elif isinstance(inputs, list):\n        self.files = [Path(f).resolve() for f in inputs]\n    else:\n        raise ValueError(\"\u274c Invalid input. Provide a list of files, a directory path, or a single file path.\")\n\n    if not self.files:\n        raise ValueError(\"\u274c No valid ligand files found.\")\n\n    # Store preparation parameters\n    self.minimize = minimize\n    self.remove_water = remove_water\n    self.add_hydrogens = add_hydrogens\n    self.add_charges = add_charges\n    self.preserve_charge_types = preserve_charge_types\n\n    self.results: List[Dict[str, Union[str, Path, bool]]] = []\n</code></pre>"},{"location":"api/batch-ligand/#docksuitex.batch_docking.batch_ligand.BatchLigand.prepare_all","title":"prepare_all","text":"<pre><code>prepare_all(\n    save_to: Union[str, Path],\n    cpu: int = os.cpu_count() or 1,\n) -&gt; List[Dict[str, Union[str, Path, bool]]]\n</code></pre> <p>Prepare all ligands in batch and save PDBQT files to the specified folder.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>str | Path</code> <p>Directory to save all prepared PDBQT files.</p> required <code>cpu</code> <code>int</code> <p>Total number of CPU cores to use. Defaults to all available cores. Each worker uses 1 CPU.</p> <code>cpu_count() or 1</code> <p>Returns:</p> Type Description <code>List[Dict[str, Union[str, Path, bool]]]</code> <p>list[dict]: Result dictionary for each ligand file.</p> Source code in <code>docksuitex\\batch_docking\\batch_ligand.py</code> <pre><code>def prepare_all(\n    self,\n    save_to: Union[str, Path],\n    cpu: int = os.cpu_count() or 1,\n) -&gt; List[Dict[str, Union[str, Path, bool]]]:\n    \"\"\"\n    Prepare all ligands in batch and save PDBQT files to the specified folder.\n\n    Args:\n        save_to (str | Path): Directory to save all prepared PDBQT files.\n        cpu (int, optional): Total number of CPU cores to use.\n            Defaults to all available cores. Each worker uses 1 CPU.\n\n    Returns:\n        list[dict]: Result dictionary for each ligand file.\n    \"\"\"\n    save_to = Path(save_to).resolve()\n    save_to.mkdir(parents=True, exist_ok=True)\n\n    # Simple strategy: Divide total CPUs among workers\n    n_files = len(self.files)\n    max_workers = min(cpu, n_files)\n\n    print(f\"Starting ligand preparation for {n_files} files...\")\n    print(f\"Using {max_workers} parallel workers\")\n    print(f\"Total CPU allocation: {max_workers}\")\n    print(f\"Output directory: {save_to}\")\n\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(\n                self._process_one,\n                file,\n                self.minimize,\n                self.remove_water,\n                self.add_hydrogens,\n                self.add_charges,\n                self.preserve_charge_types,\n                save_to,\n            ): file for file in self.files\n        }\n\n        for future in as_completed(futures):\n            result = future.result()\n            self.results.append(result)\n            if result[\"status\"] == \"success\":\n                print(f\"\u2705 {Path(result['file']).name} \u2192 saved to {Path(result['pdbqt_path']).name}\")\n            else:\n                print(f\"\u274c {Path(result['file']).name} failed. Error: {result.get('error', 'Unknown')}\")\n\n    print(\"Batch processing completed!\")\n    return self.results\n</code></pre>"},{"location":"api/batch-pocket-finder/","title":"BatchPocketFinder","text":""},{"location":"api/batch-pocket-finder/#docksuitex.batch_docking.batch_pocket_finder.BatchPocketFinder","title":"docksuitex.batch_docking.batch_pocket_finder.BatchPocketFinder","text":"<pre><code>BatchPocketFinder(\n    inputs: Union[List[Union[str, Path]], str, Path],\n)\n</code></pre> <p>Initialize the batch pocket finder.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>list[str | Path] | str | Path</code> <p>List of protein files (pdb/pdbqt) or directory containing them.</p> required Source code in <code>docksuitex\\batch_docking\\batch_pocket_finder.py</code> <pre><code>def __init__(\n    self,\n    inputs: Union[List[Union[str, Path]], str, Path],\n):\n    \"\"\"\n    Initialize the batch pocket finder.\n\n    Args:\n        inputs (list[str | Path] | str | Path): \n            List of protein files (pdb/pdbqt) or directory containing them.\n    \"\"\"\n    # Handle input paths\n    # Handle input paths\n    if isinstance(inputs, (str, Path)):\n        path = Path(inputs).resolve()\n        if path.is_dir():\n            # We accept .pdb and .pdbqt for pocket finding\n            self.files = [\n                f.resolve() for f in path.glob(\"*\")\n                if f.suffix.lower() in [\".pdb\", \".pdbqt\"]\n            ]\n        elif path.is_file():\n            if path.suffix.lower() in [\".pdb\", \".pdbqt\"]:\n                self.files = [path]\n            else:\n                raise ValueError(f\"\u274c Invalid file type: {path.suffix}. Supported: .pdb, .pdbqt\")\n        else:\n             raise ValueError(f\"\u274c Input path does not exist: {inputs}\")\n    elif isinstance(inputs, list):\n        self.files = [Path(f).resolve() for f in inputs]\n    else:\n        raise ValueError(\"\u274c Invalid input. Provide a list of files, a directory path, or a single file path.\")\n\n    if not self.files:\n        raise ValueError(\"\u274c No valid protein files found.\")\n\n    # Sort files to ensure deterministic order (though we return a dict now)\n    self.files.sort()\n\n    self.results: Dict[str, List[Tuple[float, float, float]]] = {}\n</code></pre>"},{"location":"api/batch-pocket-finder/#docksuitex.batch_docking.batch_pocket_finder.BatchPocketFinder.run_all","title":"run_all","text":"<pre><code>run_all(\n    save_to: Union[str, Path],\n    cpu: int = os.cpu_count() or 1,\n) -&gt; Dict[str, List[Tuple[float, float, float]]]\n</code></pre> <p>Run pocket finding for all proteins in batch.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>str | Path</code> <p>Directory to save all results.</p> required <code>cpu</code> <code>int</code> <p>Total number of CPU cores to use. Defaults to all available cores. CPUs are divided among workers, with each worker receiving multiple CPUs for P2Rank.</p> <code>cpu_count() or 1</code> <p>Returns:</p> Type Description <code>Dict[str, List[Tuple[float, float, float]]]</code> <p>Dict[str, List[Tuple[float, float, float]]]:  Dictionary mapping absolute protein file path (str) to a list of center coordinates. Example: {\"/path/to/prot1.pdbqt\": [(1.0, 2.0, 3.0), ...]}</p> Source code in <code>docksuitex\\batch_docking\\batch_pocket_finder.py</code> <pre><code>def run_all(\n    self,\n    save_to: Union[str, Path],\n    cpu: int = os.cpu_count() or 1,\n) -&gt; Dict[str, List[Tuple[float, float, float]]]:\n    \"\"\"\n    Run pocket finding for all proteins in batch.\n\n    Args:\n        save_to (str | Path): Directory to save all results.\n        cpu (int, optional): Total number of CPU cores to use.\n            Defaults to all available cores. CPUs are divided among workers,\n            with each worker receiving multiple CPUs for P2Rank.\n\n    Returns:\n        Dict[str, List[Tuple[float, float, float]]]: \n            Dictionary mapping absolute protein file path (str) to a list of center coordinates.\n            Example: {\"/path/to/prot1.pdbqt\": [(1.0, 2.0, 3.0), ...]}\n    \"\"\"\n    save_to = Path(save_to).resolve()\n    save_to.mkdir(parents=True, exist_ok=True)\n\n    # Simple strategy: Divide total CPUs among workers\n    # Each worker gets at least 1 CPU\n    n_files = len(self.files)\n\n    # Calculate number of workers and CPUs per worker\n    # Start with number of files, but limit by available CPUs\n    max_workers = min(cpu, n_files)  # Can't have more workers than CPUs or files\n    cpu_per_worker = max(1, cpu // max_workers)  # At least 1 CPU per worker\n\n    print(f\"Starting pocket finding for {n_files} proteins...\")\n    print(f\"Using {max_workers} parallel workers, {cpu_per_worker} CPUs per worker\")\n    print(f\"Total CPU allocation: {max_workers * cpu_per_worker}\")\n    print(f\"Output directory: {save_to}\")\n\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(\n                self._process_one,\n                file,\n                save_to,\n                cpu_per_worker,\n            ): file for file in self.files\n        }\n\n        for future in as_completed(futures):\n            result = future.result()\n            file_path = result[\"file\"]\n\n            if result[\"status\"] == \"success\":\n                pockets = result.get(\"pockets\", [])\n                # Extract centers from pockets list (assuming pocket is a dict with \"center\" key)\n                # Based on usage in notebook: centers = [item[\"center\"] for item in pockets]\n                centers = [p[\"center\"] for p in pockets]\n                self.results[file_path] = centers\n\n                count = len(centers)\n                print(f\"\u2705 {Path(file_path).name} \u2192 found {count} pockets, saved to {Path(result['output_dir']).name}\")\n            else:\n                print(f\"\u274c {Path(file_path).name} failed. Error: {result.get('error', 'Unknown')}\")\n                # We don't add failed files to results, or we could add empty list\n                # self.results[file_path] = [] \n\n    print(\"Batch processing completed!\")\n    return self.results\n</code></pre>"},{"location":"api/batch-protein/","title":"BatchProtein","text":""},{"location":"api/batch-protein/#docksuitex.batch_docking.batch_protein.BatchProtein","title":"docksuitex.batch_docking.batch_protein.BatchProtein","text":"<pre><code>BatchProtein(\n    inputs: Union[List[Union[str, Path]], str, Path],\n    fix_pdb: bool = True,\n    remove_heterogens: bool = True,\n    add_hydrogens: bool = True,\n    remove_water: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n)\n</code></pre> <p>Initialize the batch processor and preparation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>list[str | Path] | str | Path</code> <p>List of protein files or directory containing protein files.</p> required <code>fix_pdb, remove_heterogens, add_hydrogens, remove_water, add_charges</code> <p>Preparation parameters (same as Protein.prepare()).</p> required <code>preserve_charge_types</code> <code>list[str]</code> <p>Atom types to preserve charges for.</p> <code>None</code> Source code in <code>docksuitex\\batch_docking\\batch_protein.py</code> <pre><code>def __init__(\n    self,\n    inputs: Union[List[Union[str, Path]], str, Path],\n    fix_pdb: bool = True,\n    remove_heterogens: bool = True,\n    add_hydrogens: bool = True,\n    remove_water: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n):\n    \"\"\"\n    Initialize the batch processor and preparation parameters.\n\n    Args:\n        inputs (list[str | Path] | str | Path): \n            List of protein files or directory containing protein files.\n        fix_pdb, remove_heterogens, add_hydrogens, remove_water, add_charges: \n            Preparation parameters (same as Protein.prepare()).\n        preserve_charge_types (list[str], optional): Atom types to preserve charges for.\n    \"\"\"\n    # Handle input paths\n    if isinstance(inputs, (str, Path)):\n        path = Path(inputs).resolve()\n        if path.is_dir():\n            self.files = [\n                f.resolve() for f in path.glob(\"*\")\n                if f.suffix.lower() in Protein.SUPPORTED_INPUTS\n            ]\n        elif path.is_file():\n            if path.suffix.lower() in Protein.SUPPORTED_INPUTS:\n                self.files = [path]\n            else:\n                raise ValueError(f\"\u274c Invalid file type: {path.suffix}. Supported: {Protein.SUPPORTED_INPUTS}\")\n        else:\n             raise ValueError(f\"\u274c Input path does not exist: {inputs}\")\n    elif isinstance(inputs, list):\n        self.files = [Path(f).resolve() for f in inputs]\n    else:\n        raise ValueError(\"\u274c Invalid input. Provide a list of files, a directory path, or a single file path.\")\n\n    if not self.files:\n        raise ValueError(\"\u274c No valid protein files found.\")\n\n    # Store preparation parameters\n    self.fix_pdb = fix_pdb\n    self.remove_heterogens = remove_heterogens\n    self.add_hydrogens = add_hydrogens\n    self.remove_water = remove_water\n    self.add_charges = add_charges\n    self.preserve_charge_types = preserve_charge_types\n\n    self.results: List[Dict[str, Union[str, Path, bool]]] = []\n</code></pre>"},{"location":"api/batch-protein/#docksuitex.batch_docking.batch_protein.BatchProtein.prepare_all","title":"prepare_all","text":"<pre><code>prepare_all(\n    save_to: Union[str, Path],\n    cpu: int = os.cpu_count() or 1,\n) -&gt; List[Dict[str, Union[str, Path, bool]]]\n</code></pre> <p>Prepare all proteins in batch and save PDBQT files to the specified folder.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>str | Path</code> <p>Directory to save all prepared PDBQT files.</p> required <code>cpu</code> <code>int</code> <p>Total number of CPU cores to use. Defaults to all available cores. Each worker uses 1 CPU.</p> <code>cpu_count() or 1</code> <p>Returns:</p> Type Description <code>List[Dict[str, Union[str, Path, bool]]]</code> <p>list[dict]: Result dictionary for each protein file.</p> Source code in <code>docksuitex\\batch_docking\\batch_protein.py</code> <pre><code>def prepare_all(\n    self,\n    save_to: Union[str, Path],\n    cpu: int = os.cpu_count() or 1,\n) -&gt; List[Dict[str, Union[str, Path, bool]]]:\n    \"\"\"\n    Prepare all proteins in batch and save PDBQT files to the specified folder.\n\n    Args:\n        save_to (str | Path): Directory to save all prepared PDBQT files.\n        cpu (int, optional): Total number of CPU cores to use.\n            Defaults to all available cores. Each worker uses 1 CPU.\n\n    Returns:\n        list[dict]: Result dictionary for each protein file.\n    \"\"\"\n    save_to = Path(save_to).resolve()\n    save_to.mkdir(parents=True, exist_ok=True)\n\n    # Simple strategy: Divide total CPUs among workers\n    n_files = len(self.files)\n    max_workers = min(cpu, n_files)\n\n    print(f\"Starting protein preparation for {n_files} files...\")\n    print(f\"Using {max_workers} parallel workers\")\n    print(f\"Total CPU allocation: {max_workers}\")\n    print(f\"Output directory: {save_to}\")\n\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {\n            executor.submit(\n                self._process_one,\n                file,\n                self.fix_pdb,\n                self.remove_heterogens,\n                self.add_hydrogens,\n                self.remove_water,\n                self.add_charges,\n                self.preserve_charge_types,\n                save_to,\n            ): file for file in self.files\n        }\n\n        for future in as_completed(futures):\n            result = future.result()\n            self.results.append(result)\n            if result[\"status\"] == \"success\":\n                print(f\"\u2705 {Path(result['file']).name} \u2192 saved to {Path(result['pdbqt_path']).name}\")\n            else:\n                print(f\"\u274c {Path(result['file']).name} failed. Error: {result.get('error', 'Unknown')}\")\n\n    print(\"Batch processing completed!\")\n    return self.results\n</code></pre>"},{"location":"api/batch-vina/","title":"BatchVinaDocking","text":""},{"location":"api/batch-vina/#docksuitex.batch_docking.batch_vina.BatchVinaDocking","title":"docksuitex.batch_docking.batch_vina.BatchVinaDocking","text":"<pre><code>BatchVinaDocking(\n    receptors_with_centers: Dict[\n        Union[str, Path],\n        Sequence[tuple[float, float, float]],\n    ],\n    ligands: Union[Sequence[Union[str, Path]], str, Path],\n    grid_size: tuple[int, int, int] = (20, 20, 20),\n    exhaustiveness: int = 8,\n    num_modes: int = 9,\n    verbosity: int = 1,\n    seed: int | None = None,\n)\n</code></pre> <p>Batch docking manager for AutoDock Vina.</p> <p>Runs AutoDock Vina docking for multiple ligands against multiple proteins, each with its own set of binding pocket centers, in parallel using a process pool.</p> <p>Initialize a batch Vina docking job.</p> <p>Parameters:</p> Name Type Description Default <code>receptors_with_centers</code> <code>Dict[str | Path, Sequence[tuple[float, float, float]]]</code> <p>Dictionary mapping receptor PDBQT files to their list of binding pocket centers.</p> required <code>ligands</code> <code>Sequence[str | Path]</code> <p>List of ligand PDBQT files.</p> required <code>grid_size</code> <code>tuple[int, int, int]</code> <p>Dimensions of the search box in \u00c5. Defaults to (20, 20, 20).</p> <code>(20, 20, 20)</code> <code>exhaustiveness</code> <code>int</code> <p>Sampling exhaustiveness. Higher values increase accuracy but also computation time. Defaults to 8.</p> <code>8</code> <code>num_modes</code> <code>int</code> <p>Maximum number of binding modes. Defaults to 9.</p> <code>9</code> <code>verbosity</code> <code>int</code> <p>Verbosity level (0 = quiet, 1 = normal, 2 = verbose). Defaults to 1.</p> <code>1</code> <code>seed</code> <code>int</code> <p>Random seed. If None, Vina selects automatically.</p> <code>None</code> Source code in <code>docksuitex\\batch_docking\\batch_vina.py</code> <pre><code>def __init__(\n    self,\n    receptors_with_centers: Dict[Union[str, Path], Sequence[tuple[float, float, float]]],\n    ligands: Union[Sequence[Union[str, Path]], str, Path],\n    grid_size: tuple[int, int, int] = (20, 20, 20),\n    exhaustiveness: int = 8,\n    num_modes: int = 9,\n    verbosity: int = 1,\n    seed: int | None = None,\n):\n    \"\"\"Initialize a batch Vina docking job.\n\n    Args:\n        receptors_with_centers (Dict[str | Path, Sequence[tuple[float, float, float]]]): \n            Dictionary mapping receptor PDBQT files to their list of binding pocket centers.\n        ligands (Sequence[str | Path]): List of ligand PDBQT files.\n        grid_size (tuple[int, int, int], optional):\n            Dimensions of the search box in \u00c5. Defaults to (20, 20, 20).\n        exhaustiveness (int, optional):\n            Sampling exhaustiveness. Higher values increase accuracy but\n            also computation time. Defaults to 8.\n        num_modes (int, optional):\n            Maximum number of binding modes. Defaults to 9.\n        verbosity (int, optional):\n            Verbosity level (0 = quiet, 1 = normal, 2 = verbose).\n            Defaults to 1.\n        seed (int, optional):\n            Random seed. If None, Vina selects automatically.\n    \"\"\"\n    self.receptors = receptors_with_centers\n\n    # Handle ligands input\n    if isinstance(ligands, (str, Path)):\n        path = Path(ligands).resolve()\n        if path.is_dir():\n            self.ligands = list(path.glob(\"*.pdbqt\"))\n        elif path.is_file():\n            if path.suffix.lower() == \".pdbqt\":\n                self.ligands = [path]\n            else:\n                raise ValueError(f\"\u274c Invalid ligand file type: {path.suffix}. Must be .pdbqt\")\n        else:\n             raise ValueError(f\"\u274c Ligand input path does not exist: {ligands}\")\n    elif isinstance(ligands, list):\n        self.ligands = [Path(l).expanduser().resolve() for l in ligands]\n    else:\n        raise ValueError(\"\u274c Invalid ligands input. Provide a list of files, a directory path, or a single file path.\")\n\n    if not self.ligands:\n        raise ValueError(\"\u274c No valid ligand PDBQT files found.\")\n\n    self.grid_size = grid_size\n    self.exhaustiveness = exhaustiveness\n    self.num_modes = num_modes\n    self.seed = seed\n    self.verbosity = verbosity\n    self.results: dict[tuple[str, str, tuple[float, float, float]], Union[Path, str]] = {}\n</code></pre>"},{"location":"api/batch-vina/#docksuitex.batch_docking.batch_vina.BatchVinaDocking.run_all","title":"run_all","text":"<pre><code>run_all(\n    cpu: int = os.cpu_count() or 1,\n    save_to: Union[str, Path] = \"./batch_vina_results\",\n) -&gt; dict[\n    tuple[str, str, tuple[float, float, float]],\n    Union[Path, str],\n]\n</code></pre> <p>Run AutoDock Vina docking for all ligands \u00d7 all centers \u00d7 all receptors in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>cpu</code> <code>int</code> <p>Total number of CPU cores to use. Defaults to all available cores. CPUs are divided among workers, with each worker receiving multiple CPUs for Vina.</p> <code>cpu_count() or 1</code> <code>save_to</code> <code>str | Path</code> <p>Directory where docking results will be stored. Defaults to \"./batch_vina_results\".</p> <code>'./batch_vina_results'</code> <p>Returns:</p> Type Description <code>dict[tuple[str, str, tuple[float, float, float]], Union[Path, str]]</code> <p>dict[tuple[str, str, tuple[float, float, float]], Path | str]: Mapping from (receptor_name, ligand_name, center) to: - Path: Path to the docking result file, if successful. - str: Error message if the docking failed.</p> Source code in <code>docksuitex\\batch_docking\\batch_vina.py</code> <pre><code>def run_all(\n    self,\n    cpu: int = os.cpu_count() or 1,\n    save_to: Union[str, Path] = \"./batch_vina_results\",\n) -&gt; dict[tuple[str, str, tuple[float, float, float]], Union[Path, str]]:\n    \"\"\"Run AutoDock Vina docking for all ligands \u00d7 all centers \u00d7 all receptors in parallel.\n\n    Args:\n        cpu (int, optional): Total number of CPU cores to use.\n            Defaults to all available cores. CPUs are divided among workers,\n            with each worker receiving multiple CPUs for Vina.\n        save_to (str | Path, optional): Directory where docking\n            results will be stored. Defaults to \"./batch_vina_results\".\n\n    Returns:\n        dict[tuple[str, str, tuple[float, float, float]], Path | str]:\n            Mapping from (receptor_name, ligand_name, center) to:\n            - Path: Path to the docking result file, if successful.\n            - str: Error message if the docking failed.\n    \"\"\"\n    save_to = Path(save_to).expanduser().resolve()\n    save_to.mkdir(parents=True, exist_ok=True)\n\n    # Simple strategy: Divide total CPUs among workers\n    # Each worker gets at least 1 CPU\n    total_tasks = sum(len(self.ligands) * len(centers) for centers in self.receptors.values())\n\n    # Calculate number of workers and CPUs per worker\n    max_workers = min(cpu, total_tasks)  # Can't have more workers than CPUs or tasks\n    vina_cpu = max(1, cpu // max_workers)  # At least 1 CPU per worker\n\n    print(f\"Starting AutoDock Vina docking for {total_tasks} tasks...\")\n    print(f\"Using {max_workers} parallel workers, {vina_cpu} CPUs per worker\")\n    print(f\"Total CPU allocation: {max_workers * vina_cpu}\")\n    print(f\"Output directory: {save_to}\")\n\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        futures = {}\n        for receptor_path, centers in self.receptors.items():\n            receptor = Path(receptor_path).expanduser().resolve()\n            for center in centers:\n                for lig in self.ligands:\n                    future = executor.submit(self._dock_one, save_to, receptor, lig, center, vina_cpu)\n                    futures[future] = (receptor, lig, center)\n\n        for future in as_completed(futures):\n            receptor, lig, center = futures[future]\n            try:\n                rec_name, lig_name, ctr, path = future.result()\n                self.results[(rec_name, lig_name, ctr)] = path\n                center_str = \"_\".join(f\"{c:.2f}\" for c in ctr)\n                print(f\"\u2705 {rec_name} + {lig_name} @ center {center_str} \u2192 saved to {Path(path).name}\")\n            except Exception as e:\n                self.results[(receptor.name, lig.name, center)] = f\"\u274c Failed: {e}\"\n                center_str = \"_\".join(f\"{c:.2f}\" for c in center)\n                print(f\"\u274c {receptor.name} + {lig.name} @ center {center_str} failed. Error: {e}\")\n\n    print(\"Batch processing completed!\")\n    return self.results\n</code></pre>"},{"location":"api/cleaner/","title":"Cleaner","text":""},{"location":"api/cleaner/#docksuitex.utils.cleaner","title":"docksuitex.utils.cleaner","text":""},{"location":"api/cleaner/#docksuitex.utils.cleaner.delete_binaries","title":"delete_binaries","text":"<pre><code>delete_binaries()\n</code></pre> <p>Delete the DockSuiteX binaries directory and all its contents.</p> <p>This function removes the entire <code>bin/</code> directory containing all bundled executables (MGLTools, AutoDock Vina, AutoDock4, P2Rank, Open Babel). Use this to clean up disk space or force a fresh download of binaries.</p> <p>The binaries will be automatically re-downloaded on the next import of DockSuiteX.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the directory or files are in use or protected.</p> Warning <p>This will delete all binary executables. They will need to be re-downloaded (~500MB) on next import.</p> Example <p>::</p> <pre><code>from docksuitex.utils import delete_binaries\n\n# Remove all binaries\ndelete_binaries()\n\n# Binaries will be re-downloaded on next import\nimport docksuitex  # Triggers download\n</code></pre> Source code in <code>docksuitex\\utils\\cleaner.py</code> <pre><code>def delete_binaries():\n    \"\"\"Delete the DockSuiteX binaries directory and all its contents.\n\n    This function removes the entire `bin/` directory containing all bundled\n    executables (MGLTools, AutoDock Vina, AutoDock4, P2Rank, Open Babel).\n    Use this to clean up disk space or force a fresh download of binaries.\n\n    The binaries will be automatically re-downloaded on the next import of\n    DockSuiteX.\n\n    Raises:\n        PermissionError: If the directory or files are in use or protected.\n\n    Warning:\n        This will delete all binary executables. They will need to be\n        re-downloaded (~500MB) on next import.\n\n    Example:\n        ::\n\n            from docksuitex.utils import delete_binaries\n\n            # Remove all binaries\n            delete_binaries()\n\n            # Binaries will be re-downloaded on next import\n            import docksuitex  # Triggers download\n    \"\"\"\n    if BIN_DIR.exists() and BIN_DIR.is_dir():\n        shutil.rmtree(BIN_DIR)\n        print(f\"\ud83d\uddd1\ufe0f Deleted {BIN_DIR}\")\n    else:\n        print(f\"\u26a0\ufe0f {BIN_DIR} does not exist.\")\n</code></pre>"},{"location":"api/fetcher/","title":"Fetcher","text":""},{"location":"api/fetcher/#docksuitex.utils.fetcher","title":"docksuitex.utils.fetcher","text":"<p>Structure fetching from online databases.</p> <p>This module provides functions for downloading protein and ligand structures from public databases including RCSB PDB and PubChem. It automates the process of retrieving structures for docking studies.</p> The fetching functions handle <ul> <li>Protein structure download from RCSB PDB</li> <li>Ligand structure download from PubChem</li> <li>Batch downloading of multiple structures</li> <li>Automatic file naming and organization</li> </ul> Example <p>Fetching protein structures::</p> <pre><code>from docksuitex.utils import fetch_pdb\n\n# Download single protein\npdb_path = fetch_pdb(\"1UBQ\", save_to=\"structures\")\n\n# Download multiple proteins\npaths = fetch_pdb([\"1UBQ\", \"2HHB\", \"3CL0\"], save_to=\"proteins\")\n</code></pre> <p>Fetching ligand structures::</p> <pre><code>from docksuitex.utils import fetch_sdf\n\n# Download ligand from PubChem\nsdf_path = fetch_sdf(\"2244\", save_to=\"ligands\")  # Aspirin\n\n# Download multiple ligands\npaths = fetch_sdf([2244, 5090, 6323], save_to=\"ligands\")\n</code></pre> Note <p>These functions require an active internet connection and access to the respective databases. Rate limiting may apply for batch downloads.</p>"},{"location":"api/fetcher/#docksuitex.utils.fetcher.fetch_pdb","title":"fetch_pdb","text":"<pre><code>fetch_pdb(\n    pdbid: Union[str, List[str]],\n    save_to: Union[str, Path] = \".\",\n) -&gt; Union[Path, List[Path]]\n</code></pre> <p>Download PDB structure file(s) from the RCSB Protein Data Bank.</p> <p>This function downloads the <code>.pdb</code> file(s) corresponding to the given 4-character PDB ID(s).</p> <p>Parameters:</p> Name Type Description Default <code>pdbid</code> <code>str | List[str]</code> <p>The 4-character alphanumeric PDB ID (e.g., \"1UBQ\") or a list of PDB IDs.</p> required <code>save_to</code> <code>str | Path</code> <p>Directory to save the file(s). Defaults to the current directory.</p> <code>'.'</code> <p>Returns:</p> Type Description <code>Union[Path, List[Path]]</code> <p>Path | List[Path]: The absolute path(s) to the downloaded <code>.pdb</code> file(s).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>pdbid</code> is not a valid 4-character alphanumeric string.</p> <code>RequestException</code> <p>If the network request fails.</p> <code>RuntimeError</code> <p>If the PDB file cannot be retrieved (e.g., invalid ID).</p> Source code in <code>docksuitex\\utils\\fetcher.py</code> <pre><code>def fetch_pdb(pdbid: Union[str, List[str]], save_to: Union[str, Path] = \".\") -&gt; Union[Path, List[Path]]:\n    \"\"\"Download PDB structure file(s) from the RCSB Protein Data Bank.\n\n    This function downloads the `.pdb` file(s) corresponding to the given\n    4-character PDB ID(s).\n\n    Args:\n        pdbid (str | List[str]): The 4-character alphanumeric PDB ID (e.g., \"1UBQ\")\n            or a list of PDB IDs.\n        save_to (str | Path, optional): Directory to save the file(s).\n            Defaults to the current directory.\n\n    Returns:\n        Path | List[Path]: The absolute path(s) to the downloaded `.pdb` file(s).\n\n    Raises:\n        ValueError: If `pdbid` is not a valid 4-character alphanumeric string.\n        requests.RequestException: If the network request fails.\n        RuntimeError: If the PDB file cannot be retrieved (e.g., invalid ID).\n    \"\"\"\n    if isinstance(pdbid, list):\n        return [fetch_pdb(pid, save_to) for pid in pdbid]\n\n    pdbid = pdbid.upper().strip()\n    if len(pdbid) != 4 or not pdbid.isalnum():\n        raise ValueError(\n            \"\u274c Invalid PDB ID. It must be a 4-character alphanumeric string.\")\n\n    url = f\"https://files.rcsb.org/download/{pdbid}.pdb\"\n    save_path = Path(save_to).expanduser().resolve() / f\"{pdbid}.pdb\"\n    save_path.parent.mkdir(parents=True, exist_ok=True)\n\n    response = requests.get(url)\n    if response.status_code != 200:\n        raise RuntimeError(f\"\u274c Failed to download PDB file from: {url}\")\n\n    with open(save_path, \"w\") as f:\n        f.write(response.text)\n\n    print(f\"\u2705 Downloaded {pdbid}.pdb \u2192 saved to {save_path}\")\n    return save_path\n</code></pre>"},{"location":"api/fetcher/#docksuitex.utils.fetcher.fetch_sdf","title":"fetch_sdf","text":"<pre><code>fetch_sdf(\n    cid: Union[str, int, List[Union[str, int]]],\n    save_to: Union[str, Path] = \".\",\n) -&gt; Union[Path, List[Path]]\n</code></pre> <p>Download 3D SDF structure file(s) from PubChem using Compound ID(s).</p> <p>This function downloads the <code>.sdf</code> file(s) corresponding to the given PubChem CID(s).</p> <p>Parameters:</p> Name Type Description Default <code>cid</code> <code>str | int | List[str | int]</code> <p>The numeric Compound ID (e.g., 2244 for Aspirin) or a list of CIDs.</p> required <code>save_to</code> <code>str | Path</code> <p>Directory to save the file(s). Defaults to the current directory.</p> <code>'.'</code> <p>Returns:</p> Type Description <code>Union[Path, List[Path]]</code> <p>Path | List[Path]: The absolute path(s) to the downloaded <code>.sdf</code> file(s).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>cid</code> is not a valid integer identifier.</p> <code>RequestException</code> <p>If the network request fails.</p> <code>RuntimeError</code> <p>If the SDF file cannot be retrieved or is empty.</p> Source code in <code>docksuitex\\utils\\fetcher.py</code> <pre><code>def fetch_sdf(cid: Union[str, int, List[Union[str, int]]], save_to: Union[str, Path] = \".\") -&gt; Union[Path, List[Path]]:\n    \"\"\"Download 3D SDF structure file(s) from PubChem using Compound ID(s).\n\n    This function downloads the `.sdf` file(s) corresponding to the given\n    PubChem CID(s).\n\n    Args:\n        cid (str | int | List[str | int]): The numeric Compound ID (e.g., 2244 for Aspirin)\n            or a list of CIDs.\n        save_to (str | Path, optional): Directory to save the file(s).\n            Defaults to the current directory.\n\n    Returns:\n        Path | List[Path]: The absolute path(s) to the downloaded `.sdf` file(s).\n\n    Raises:\n        ValueError: If `cid` is not a valid integer identifier.\n        requests.RequestException: If the network request fails.\n        RuntimeError: If the SDF file cannot be retrieved or is empty.\n    \"\"\"\n    if isinstance(cid, list):\n        return [fetch_sdf(c, save_to) for c in cid]\n\n    cid = str(cid).strip()\n    if not cid.isdigit():\n        raise ValueError(\"\u274c Invalid CID. It must be a numeric ID.\")\n\n    url = f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{cid}/SDF?record_type=3d\"\n    save_path = Path(save_to).expanduser().resolve() / f\"{cid}.sdf\"\n    save_path.parent.mkdir(parents=True, exist_ok=True)\n\n    response = requests.get(url)\n    if response.status_code != 200 or not response.text.strip():\n        raise RuntimeError(f\"\u274c Failed to download SDF file from: {url}\")\n\n    with open(save_path, \"w\") as f:\n        f.write(response.text)\n\n    print(f\"\u2705 Downloaded {cid}.sdf \u2192 saved to {save_path}\")\n    return save_path\n</code></pre>"},{"location":"api/ligand/","title":"Ligand","text":""},{"location":"api/ligand/#docksuitex.ligand.Ligand","title":"docksuitex.ligand.Ligand","text":"<pre><code>Ligand(\n    input: Union[str, Path],\n    minimize: Optional[str] = None,\n    remove_water: bool = True,\n    add_hydrogens: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n)\n</code></pre> <p>Automated ligand structure preparation for molecular docking.</p> <p>This class provides a complete workflow for preparing ligand structures for docking simulations. It integrates Open Babel for format conversion and energy minimization, and AutoDockTools for PDBQT generation.</p> The preparation process handles <ul> <li>Format conversion from various structure formats to MOL2</li> <li>3D coordinate generation for 2D structures or SMILES</li> <li>Energy minimization with multiple forcefields</li> <li>Water molecule removal</li> <li>Hydrogen addition (polar or all)</li> <li>Gasteiger charge assignment</li> <li>PDBQT format conversion for docking</li> </ul> <p>Attributes:</p> Name Type Description <code>SUPPORTED_INPUTS</code> <code>set</code> <p>Supported input file formats (mol2, sdf, pdb, mol, smi).</p> <code>SUPPORTED_FORCEFIELDS</code> <code>set</code> <p>Supported forcefields for minimization.</p> <code>file_path</code> <code>Path</code> <p>Path to the input ligand file.</p> <code>input_format</code> <code>str</code> <p>Detected input file format.</p> <code>mol2_path</code> <code>Path | None</code> <p>Path to intermediate MOL2 file.</p> <code>pdbqt_path</code> <code>Path | None</code> <p>Path to final PDBQT file (set after prepare()).</p> <code>minimize</code> <code>str | None</code> <p>Forcefield for energy minimization.</p> <code>remove_water</code> <code>bool</code> <p>Whether to remove water molecules.</p> <code>add_hydrogens</code> <code>bool</code> <p>Whether to add hydrogen atoms.</p> <code>add_charges</code> <code>bool</code> <p>Whether to assign Gasteiger charges.</p> <code>preserve_charge_types</code> <code>list[str] | None</code> <p>Atom types to preserve charges for.</p> Example <p>Standard ligand preparation::</p> <pre><code>from docksuitex import Ligand\n\nligand = Ligand(\"compound.sdf\", minimize=\"mmff94\")\npdbqt_file = ligand.prepare(save_to=\"ligand.pdbqt\")\n</code></pre> <p>Preparation from SMILES::</p> <pre><code>ligand = Ligand(\"molecule.smi\", minimize=\"uff\")\npdbqt_file = ligand.prepare()\n</code></pre> Note <p>Temporary files are created in a <code>temp/Ligands/</code> directory and are not automatically cleaned up. The final PDBQT file is saved to the specified location.</p> <p>Initialize a Ligand object with a given input file and preparation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | Path</code> <p>Path to the ligand input file.</p> required <code>minimize</code> <code>str</code> <p>Forcefield for energy minimization (\"mmff94\", \"mmff94s\", \"uff\", \"gaff\").</p> <code>None</code> <code>remove_water</code> <code>bool</code> <p>Remove water molecules. Defaults to True.</p> <code>True</code> <code>add_hydrogens</code> <code>bool</code> <p>Add polar hydrogens. Defaults to True.</p> <code>True</code> <code>add_charges</code> <code>bool</code> <p>Assign Gasteiger charges. Defaults to True.</p> <code>True</code> <code>preserve_charge_types</code> <code>list[str]</code> <p>Atom types to preserve charges for. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the input file does not exist.</p> <code>ValueError</code> <p>If the file extension is unsupported.</p> Source code in <code>docksuitex\\ligand.py</code> <pre><code>def __init__(\n    self,\n    input: Union[str, Path],\n    minimize: Optional[str] = None,\n    remove_water: bool = True,\n    add_hydrogens: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n):\n    \"\"\"Initialize a Ligand object with a given input file and preparation parameters.\n\n    Args:\n        input (str | Path): Path to the ligand input file.\n        minimize (str, optional): Forcefield for energy minimization (\"mmff94\", \"mmff94s\", \"uff\", \"gaff\").\n        remove_water (bool, optional): Remove water molecules. Defaults to True.\n        add_hydrogens (bool, optional): Add polar hydrogens. Defaults to True.\n        add_charges (bool, optional): Assign Gasteiger charges. Defaults to True.\n        preserve_charge_types (list[str], optional): Atom types to preserve charges for. Defaults to None.\n\n    Raises:\n        FileNotFoundError: If the input file does not exist.\n        ValueError: If the file extension is unsupported.\n    \"\"\"\n    self.file_path = Path(input).resolve()\n    self.mol2_path: Optional[Path] = None\n    self.pdbqt_path: Optional[Path] = None\n\n    if not self.file_path.is_file():\n        raise FileNotFoundError(\n            f\"\u274c Ligand file not found: {self.file_path}\")\n\n    ext = self.file_path.suffix.lower().lstrip(\".\")\n    if ext not in self.SUPPORTED_INPUTS:\n        raise ValueError(\n            f\"\u274c Unsupported file format '.{ext}'. Supported formats: {self.SUPPORTED_INPUTS}\")\n    self.input_format = ext\n\n    # Store preparation parameters\n    self.minimize = minimize\n    self.remove_water = remove_water\n    self.add_hydrogens = add_hydrogens\n    self.add_charges = add_charges\n    self.preserve_charge_types = preserve_charge_types\n</code></pre>"},{"location":"api/ligand/#docksuitex.ligand.Ligand.prepare","title":"prepare","text":"<pre><code>prepare(save_to: Union[str, Path] = '.') -&gt; Path\n</code></pre> <p>Prepare the ligand by converting to MOL2, optionally minimizing energy,  and generating a final PDBQT file using AutoDockTools (from MGLTools). Saves the prepared PDBQT file to the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>str | Path</code> <p>Destination file or directory. - If directory: saves with the original filename. - If file path: saves with the given name. Defaults to current directory.</p> <code>'.'</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the saved PDBQT file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported forcefield or input format is provided.</p> <code>RuntimeError</code> <p>If AutoDockTools fails to generate the PDBQT file.</p> Source code in <code>docksuitex\\ligand.py</code> <pre><code>def prepare(self, save_to: Union[str, Path] = \".\") -&gt; Path:\n    \"\"\"\n    Prepare the ligand by converting to MOL2, optionally minimizing energy, \n    and generating a final PDBQT file using AutoDockTools (from MGLTools).\n    Saves the prepared PDBQT file to the specified location.\n\n    Args:\n        save_to (str | Path, optional): Destination file or directory.\n            - If directory: saves with the original filename.\n            - If file path: saves with the given name.\n            Defaults to current directory.\n\n    Returns:\n        Path: Path to the saved PDBQT file.\n\n    Raises:\n        ValueError: If an unsupported forcefield or input format is provided.\n        RuntimeError: If AutoDockTools fails to generate the PDBQT file.\n    \"\"\"\n    # Create a unique temp directory per object\n    self.temp_dir = TEMP_DIR / \"Ligands\" / f\"{self.file_path.stem}_{uuid.uuid4().hex[:8]}\"\n    self.temp_dir.mkdir(parents=True, exist_ok=True)\n\n    # === Step 1: Convert + Gen3D + Minimize to MOL2 ===\n    self.mol2_path = self.temp_dir / f\"{self.file_path.stem}.mol2\"\n    cmd = [\n        str(OBABEL_EXE), \"-i\", self.input_format, str(self.file_path),\n        \"-o\", \"mol2\", \"-O\", str(self.mol2_path),\n        \"--gen3d\"\n    ]\n\n    # Universal water removal: works for PDB (HOH) + all other formats ([#8H2])\n    if self.remove_water:\n        cmd += [\"--delete\", \"HOH\", \"--delete\", \"[#8H2]\"]\n\n    if self.minimize:\n        forcefield = self.minimize.lower()\n        if forcefield not in self.SUPPORTED_FORCEFIELDS:\n            raise ValueError(\n                f\"\u274c Unsupported forcefield '{forcefield}'. Supported: {self.SUPPORTED_FORCEFIELDS}\")\n        cmd += [\"--minimize\", \"--ff\", forcefield]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    if result.returncode != 0:\n        raise RuntimeError(f\"\u274c OpenBabel failed:\\n{result.stderr}\")\n\n    # === Step 2: MGLTools to PDBQT ===\n\n    save_to = Path(save_to).expanduser().resolve()\n\n    # treat as file only if it has a suffix (e.g., .pdbqt)\n    if not save_to.suffix:\n        save_to = save_to / f\"{self.file_path.stem}.pdbqt\"\n\n    save_to.parent.mkdir(parents=True, exist_ok=True)\n\n    mgl_cmd = [\n        str(MGL_PYTHON_EXE), str(PREPARE_LIGAND_SCRIPT),\n        \"-l\", self.mol2_path, \"-o\", save_to,\n        \"-U\", \"nphs_lps\"\n    ]\n    # ADT prepare_ligand4.py doesn't have -U waters flag, remove water is handled by obabel\n\n    if self.add_hydrogens:\n        mgl_cmd += [\"-A\", \"hydrogens\"]\n    else:\n        mgl_cmd += [\"-A\", \"None\"]\n\n    # Charge options\n    if not self.add_charges:\n        mgl_cmd += [\"-C\"]  # preserve all charges\n    elif self.preserve_charge_types:\n        for atom_type in self.preserve_charge_types:\n            mgl_cmd += [\"-p\", atom_type]\n\n    result = subprocess.run(\n        mgl_cmd,\n        text=True,\n        capture_output=True,\n        cwd=self.temp_dir\n    )\n\n    if result.returncode != 0:\n        raise RuntimeError(f\"\u274c MGLTools ligand preparation failed:\\n{result.stderr}\")\n\n    self.pdbqt_path = save_to\n\n    # # Save logic (merged from save_pdbqt)\n    # save_to = Path(save_to).expanduser().resolve()\n\n    # # treat as file only if it has a suffix (e.g., .pdbqt)\n    # if not save_to.suffix:\n    #     save_to = save_to / self.pdbqt_path.name\n\n    # save_to.parent.mkdir(parents=True, exist_ok=True)\n    # shutil.copy2(self.pdbqt_path, save_to)\n    print(f\"\u2705 Ligand prepared successfully: {self.pdbqt_path}\")\n    return self.pdbqt_path\n</code></pre>"},{"location":"api/ligand/#docksuitex.ligand.Ligand.view_molecule","title":"view_molecule","text":"<pre><code>view_molecule()\n</code></pre> <p>Visualize the ligand structure in a Jupyter notebook.</p> <p>Uses nglview to render either the prepared or original file.</p> <p>Returns:</p> Name Type Description <code>object</code> <p>An nglview.NGLWidget object for rendering.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If neither prepared nor input file exists.</p> Source code in <code>docksuitex\\ligand.py</code> <pre><code>def view_molecule(self):\n    \"\"\"Visualize the ligand structure in a Jupyter notebook.\n\n    Uses nglview to render either the prepared or original file.\n\n    Returns:\n        object: An nglview.NGLWidget object for rendering.\n\n    Raises:\n        FileNotFoundError: If neither prepared nor input file exists.\n    \"\"\"\n    path = Path(self.pdbqt_path if self.pdbqt_path else self.file_path).resolve()\n    return view_molecule(file_path=path)\n</code></pre>"},{"location":"api/parser/","title":"Parser","text":""},{"location":"api/parser/#docksuitex.utils.parser","title":"docksuitex.utils.parser","text":"<p>Docking output file parsing utilities.</p> <p>This module provides functions for parsing AutoDock Vina and AutoDock4 output files into structured CSV format for analysis. It extracts binding energies, grid parameters, and clustering information from log files.</p> The parsing functions handle <ul> <li>AutoDock Vina log file parsing (log.txt)</li> <li>AutoDock4 DLG file parsing (results.dlg)</li> <li>Recursive directory scanning for batch results</li> <li>CSV export with standardized columns</li> </ul> Example <p>Parsing Vina results::</p> <pre><code>from docksuitex.utils import parse_vina_log_to_csv\n\n# Parse all Vina results in directory\nparse_vina_log_to_csv(\n    results_dir=\"vina_docking_results\",\n    output_csv=\"vina_summary.csv\"\n)\n</code></pre> <p>Parsing AutoDock4 results::</p> <pre><code>from docksuitex.utils import parse_ad4_dlg_to_csv\n\n# Parse all AD4 results\nparse_ad4_dlg_to_csv(\n    results_dir=\"ad4_docking_results\",\n    output_csv=\"ad4_summary.csv\"\n)\n</code></pre> Note <p>The parsers expect standard output formats from AutoDock Vina and AutoDock4. Custom output formats may not be parsed correctly.</p>"},{"location":"api/parser/#docksuitex.utils.parser.parse_vina_log_to_csv","title":"parse_vina_log_to_csv","text":"<pre><code>parse_vina_log_to_csv(\n    results_dir: Union[str, Path],\n    output_csv: Union[str, Path] = \"vina_summary.csv\",\n) -&gt; pd.DataFrame\n</code></pre> <p>Parse AutoDock Vina log files into a structured CSV summary.</p> <p>This function scans a directory tree for Vina docking log files (<code>log.txt</code>), extracts receptor/ligand names, grid box parameters, and docking results (affinity and RMSD values), then writes the results to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str | Path</code> <p>Path to the directory containing docking result subfolders. Each folder should include a <code>log.txt</code> file from AutoDock Vina.</p> required <code>output_csv</code> <code>str | Path</code> <p>Path to save the generated CSV summary. Defaults to \"vina_summary.csv\" in the current directory.</p> <code>'vina_summary.csv'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing parsed docking results with columns: - Receptor, Ligand - Mode, Affinity (kcal/mol), RMSD LB, RMSD UB - Grid Center (X, Y, Z), Grid Size (X, Y, Z), Grid Spacing - Exhaustiveness</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no <code>log.txt</code> files are found under <code>results_dir</code>.</p> <code>RuntimeError</code> <p>If parsing fails or no docking results are extracted.</p> Source code in <code>docksuitex\\utils\\parser.py</code> <pre><code>def parse_vina_log_to_csv(\n    results_dir: Union[str, Path],\n    output_csv: Union[str, Path] = \"vina_summary.csv\"\n) -&gt; pd.DataFrame:\n    \"\"\"Parse AutoDock Vina log files into a structured CSV summary.\n\n    This function scans a directory tree for Vina docking log files (`log.txt`),\n    extracts receptor/ligand names, grid box parameters, and docking results\n    (affinity and RMSD values), then writes the results to a CSV file.\n\n    Args:\n        results_dir (str | Path): Path to the directory containing docking result subfolders.\n            Each folder should include a `log.txt` file from AutoDock Vina.\n        output_csv (str | Path, optional): Path to save the generated CSV summary.\n            Defaults to \"vina_summary.csv\" in the current directory.\n\n    Returns:\n        pd.DataFrame: DataFrame containing parsed docking results with columns:\n            - Receptor, Ligand\n            - Mode, Affinity (kcal/mol), RMSD LB, RMSD UB\n            - Grid Center (X, Y, Z), Grid Size (X, Y, Z), Grid Spacing\n            - Exhaustiveness\n\n    Raises:\n        FileNotFoundError: If no `log.txt` files are found under `results_dir`.\n        RuntimeError: If parsing fails or no docking results are extracted.\n    \"\"\"\n    results_dir = Path(results_dir).expanduser().resolve()\n    log_files = list(results_dir.rglob(\"log.txt\"))\n    if not log_files:\n        raise FileNotFoundError(f\"No Vina log.txt files found in {results_dir}\")\n\n    print(f\"Starting Vina log parsing for {len(log_files)} files...\")\n    print(f\"Scanning directory: {results_dir}\")\n    results = []\n\n    for log_file in log_files:\n        with open(log_file, \"r\", encoding=\"utf-8\") as f:\n            text = f.read()\n\n        # Extract receptor and ligand names\n        receptor_match = re.search(r\"Rigid receptor:\\s*(.+\\.pdbqt)\", text)\n        ligand_match = re.search(r\"Ligand:\\s*(.+\\.pdbqt)\", text)\n        receptor_name = Path(receptor_match.group(1)).stem if receptor_match else \"Unknown\"\n        ligand_name = Path(ligand_match.group(1)).stem if ligand_match else \"Unknown\"\n\n        # Extract grid and parameters\n        grid_center = re.search(r\"Grid center:\\s*X\\s*([-\\d.]+)\\s*Y\\s*([-\\d.]+)\\s*Z\\s*([-\\d.]+)\", text)\n        grid_size = re.search(r\"Grid size\\s*:\\s*X\\s*([-\\d.]+)\\s*Y\\s*([-\\d.]+)\\s*Z\\s*([-\\d.]+)\", text)\n        grid_space = re.search(r\"Grid space\\s*:\\s*([-\\d.]+)\", text)\n        exhaustiveness = re.search(r\"Exhaustiveness:\\s*(\\d+)\", text)\n\n        # Extract docking results table\n        docking_results = re.findall(\n            r\"^\\s*(\\d+)\\s+([-\\d.]+)\\s+([-\\d.]+)\\s+([-\\d.]+)\", text, re.MULTILINE\n        )\n\n        for mode, affinity, rmsd_lb, rmsd_ub in docking_results:\n            results.append({\n                \"Receptor\": receptor_name,\n                \"Ligand\": ligand_name,\n                \"Grid Center X\": float(grid_center.group(1)) if grid_center else None,\n                \"Grid Center Y\": float(grid_center.group(2)) if grid_center else None,\n                \"Grid Center Z\": float(grid_center.group(3)) if grid_center else None,\n                \"Grid Size X\": float(grid_size.group(1)) if grid_size else None,\n                \"Grid Size Y\": float(grid_size.group(2)) if grid_size else None,\n                \"Grid Size Z\": float(grid_size.group(3)) if grid_size else None,\n                \"Grid Spacing\": float(grid_space.group(1)) if grid_space else None,\n                \"Exhaustiveness\": int(exhaustiveness.group(1)) if exhaustiveness else None,\n                \"Mode\": int(mode),\n                \"Affinity (kcal/mol)\": float(affinity),\n                \"RMSD LB\": float(rmsd_lb),\n                \"RMSD UB\": float(rmsd_ub),\n            })\n\n        print(f\"\u2705 Parsed {log_file.parent.name}/log.txt \u2192 {len(docking_results)} modes\")\n\n    df = pd.DataFrame(results)\n    df.to_csv(output_csv, index=False)\n    print(f\"\\n\u2705 Parsing completed! Saved {len(results)} results to {output_csv}\")\n    return df\n</code></pre>"},{"location":"api/parser/#docksuitex.utils.parser.parse_ad4_dlg_to_csv","title":"parse_ad4_dlg_to_csv","text":"<pre><code>parse_ad4_dlg_to_csv(\n    results_dir: Union[str, Path],\n    output_csv: Union[str, Path] = \"ad4_summary.csv\",\n) -&gt; pd.DataFrame\n</code></pre> <p>Parse AutoDock4 DLG result files into a structured CSV summary.</p> <p>This function scans a directory tree for AutoDock4 docking log files (<code>results.dlg</code>), extracts receptor and ligand names, grid box parameters, genetic algorithm (GA) settings, and cluster docking results, then writes them to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>results_dir</code> <code>str | Path</code> <p>Path to the directory containing docking result subfolders. Each folder should include a <code>results.dlg</code> file from AutoDock4.</p> required <code>output_csv</code> <code>str | Path</code> <p>Path to save the generated CSV summary. Defaults to \"ad4_summary.csv\" in the current directory.</p> <code>'ad4_summary.csv'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing parsed docking results with columns: - Receptor, Ligand - Cluster_Rank, RMSD, Binding_Energy - Grid Center (X, Y, Z), Grid Size (X, Y, Z), Spacing - GA parameters (e.g., rmstol, ga_pop_size, ga_num_evals, etc.)</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no <code>results.dlg</code> files are found under <code>results_dir</code>.</p> <code>RuntimeError</code> <p>If parsing fails or cluster information cannot be extracted.</p> Source code in <code>docksuitex\\utils\\parser.py</code> <pre><code>def parse_ad4_dlg_to_csv(\n    results_dir: Union[str, Path],\n    output_csv: Union[str, Path] = \"ad4_summary.csv\"\n) -&gt; pd.DataFrame:\n    \"\"\"Parse AutoDock4 DLG result files into a structured CSV summary.\n\n    This function scans a directory tree for AutoDock4 docking log files\n    (`results.dlg`), extracts receptor and ligand names, grid box parameters,\n    genetic algorithm (GA) settings, and cluster docking results, then writes\n    them to a CSV file.\n\n    Args:\n        results_dir (str | Path): Path to the directory containing docking result subfolders.\n            Each folder should include a `results.dlg` file from AutoDock4.\n        output_csv (str | Path, optional): Path to save the generated CSV summary.\n            Defaults to \"ad4_summary.csv\" in the current directory.\n\n    Returns:\n        pd.DataFrame: DataFrame containing parsed docking results with columns:\n            - Receptor, Ligand\n            - Cluster_Rank, RMSD, Binding_Energy\n            - Grid Center (X, Y, Z), Grid Size (X, Y, Z), Spacing\n            - GA parameters (e.g., rmstol, ga_pop_size, ga_num_evals, etc.)\n\n    Raises:\n        FileNotFoundError: If no `results.dlg` files are found under `results_dir`.\n        RuntimeError: If parsing fails or cluster information cannot be extracted.\n    \"\"\"\n    results_dir = Path(results_dir).expanduser().resolve()\n    dlg_files = list(results_dir.rglob(\"results.dlg\"))\n    if not dlg_files:\n        raise FileNotFoundError(f\"No results.dlg files found in {results_dir}\")\n\n    print(f\"Starting AutoDock4 DLG parsing for {len(dlg_files)} files...\")\n    print(f\"Scanning directory: {results_dir}\")\n    all_data = []\n\n    for dlg_file in dlg_files:\n        with open(dlg_file, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            lines = f.readlines()\n\n        receptor = ligand = None\n        center = [None, None, None]\n        size = [None, None, None]\n        spacing = None\n        ga_params = {\n            \"rmstol\": None,\n            \"ga_pop_size\": None,\n            \"ga_num_evals\": None,\n            \"ga_num_generations\": None,\n            \"ga_elitism\": None,\n            \"ga_mutation_rate\": None,\n            \"ga_crossover_rate\": None,\n            \"ga_run\": None,\n        }\n\n        in_cluster_section = False\n        cluster_info = {}\n\n        for i, line in enumerate(lines):\n            line = line.strip()\n\n            # Ligand and receptor\n            if \"Ligand PDBQT file\" in line:\n                match = re.search(r'\"(.+?)\"', line)\n                ligand = Path(match.group(1)).stem if match else None\n            if \"Macromolecule file used to create Grid Maps\" in line:\n                receptor = Path(line.split(\"=\")[-1].strip()).stem\n\n            # Grid spacing\n            if \"Grid Point Spacing\" in line:\n                match = re.search(r\"[\\d.]+\", line)\n                spacing = float(match.group(0)) if match else None\n\n            # Grid size (x/y/z points over next few lines)\n            if \"Even Number of User-specified Grid Points\" in line:\n                for j in range(i, i + 3):\n                    s = lines[j]\n                    if \"x-points\" in s:\n                        size[0] = int(re.search(r\"(\\d+)\", s).group(1))\n                    if \"y-points\" in s:\n                        size[1] = int(re.search(r\"(\\d+)\", s).group(1))\n                    if \"z-points\" in s:\n                        size[2] = int(re.search(r\"(\\d+)\", s).group(1))\n\n            # Grid center\n            if \"Coordinates of Central Grid Point of Maps\" in line:\n                vals = re.findall(r\"[-\\d.]+\", line)\n                if len(vals) &gt;= 3:\n                    center = [float(v) for v in vals[:3]]\n\n            # GA parameters\n            for key in ga_params.keys():\n                if line.startswith(f\"DPF&gt; {key}\"):\n                    match = re.search(r\"[\\d.]+\", line)\n                    if match:\n                        ga_params[key] = float(match.group(0))\n\n            # Cluster section\n            if \"LOWEST ENERGY DOCKED CONFORMATION from EACH CLUSTER\" in line:\n                in_cluster_section = True\n                continue\n\n            if in_cluster_section and line.startswith(\"MODEL\"):\n                cluster_info = {\n                    \"Receptor\": receptor,\n                    \"Ligand\": ligand,\n                    \"Center_X\": center[0],\n                    \"Center_Y\": center[1],\n                    \"Center_Z\": center[2],\n                    \"Size_X\": size[0],\n                    \"Size_Y\": size[1],\n                    \"Size_Z\": size[2],\n                    \"Spacing\": spacing,\n                    **ga_params,\n                    \"Cluster_Rank\": None,\n                    \"RMSD\": None,\n                    \"Binding_Energy\": None,\n                }\n\n            if in_cluster_section and \"Cluster Rank\" in line:\n                match = re.search(r\"Cluster Rank\\s*=\\s*(\\d+)\", line)\n                if match:\n                    cluster_info[\"Cluster_Rank\"] = int(match.group(1))\n\n            if in_cluster_section and \"RMSD from reference structure\" in line:\n                match = re.search(r\"([\\d.]+)\", line)\n                if match:\n                    cluster_info[\"RMSD\"] = float(match.group(1))\n\n            if in_cluster_section and \"Estimated Free Energy of Binding\" in line:\n                match = re.search(r\"([-+]?\\d*\\.\\d+|\\d+)\", line)\n                if match:\n                    cluster_info[\"Binding_Energy\"] = float(match.group(1))\n\n            if in_cluster_section and line.startswith(\"ENDMDL\"):\n                all_data.append(cluster_info)\n\n        print(f\"\u2705 Parsed {dlg_file.parent.name}/results.dlg \u2192 {len([d for d in all_data if d.get('Ligand') == ligand])} clusters\")\n\n    df = pd.DataFrame(all_data)\n    df.to_csv(output_csv, index=False)\n    print(f\"\\n\u2705 Parsing completed! Saved {len(all_data)} cluster results to {output_csv}\")\n    return df\n</code></pre>"},{"location":"api/pocket-finder/","title":"PocketFinder","text":""},{"location":"api/pocket-finder/#docksuitex.pocket_finder.PocketFinder","title":"docksuitex.pocket_finder.PocketFinder","text":"<pre><code>PocketFinder(\n    input: Union[str, Path], _cpu: int = os.cpu_count() or 1\n)\n</code></pre> <p>Ligand-binding pocket prediction using P2Rank.</p> <p>This class provides a wrapper for P2Rank, a machine learning-based tool for predicting ligand-binding sites in protein structures. It automates running P2Rank, parsing results, and extracting pocket center coordinates.</p> <p>P2Rank uses a template-free approach based on local chemical neighborhood features, making it fast and accurate for pocket prediction without requiring known ligand structures.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>Path</code> <p>Path to the input protein file (PDB or PDBQT).</p> Example <p>Finding pockets for docking::</p> <pre><code>from docksuitex import PocketFinder\n\nfinder = PocketFinder(\"protein.pdb\")\npockets = finder.run(save_to=\"pocket_analysis\")\n\n# Pockets are ranked by confidence\nfor i, pocket in enumerate(pockets):\n    rank = pocket[\"rank\"]\n    center = pocket[\"center\"]\n    print(f\"Pocket {rank}: center at {center}\")\n</code></pre> <p>Using pocket centers for batch docking::</p> <pre><code>finder = PocketFinder(\"receptor.pdbqt\")\npockets = finder.run()\ncenters = [p[\"center\"] for p in pockets[:3]]  # Top 3 pockets\n\n# Use centers for docking\nfor center in centers:\n    docking = VinaDocking(\n        receptor=\"receptor.pdbqt\",\n        ligand=\"ligand.pdbqt\",\n        grid_center=center\n    )\n    docking.run()\n</code></pre> Note <p>P2Rank generates multiple output files including visualizations and detailed predictions. The main CSV file is parsed to extract pocket center coordinates.</p> <p>Initialize the PocketFinder with a receptor structure.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Union[str, Path]</code> <p>Path to a protein file in <code>.pdb</code> or <code>.pdbqt</code> format.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the receptor file does not exist.</p> <code>ValueError</code> <p>If the file is not a supported format.</p> Source code in <code>docksuitex\\pocket_finder.py</code> <pre><code>def __init__(self, input: Union[str, Path], _cpu: int = os.cpu_count() or 1,):\n    \"\"\"Initialize the PocketFinder with a receptor structure.\n\n    Args:\n        input (Union[str, Path]):\n            Path to a protein file in `.pdb` or `.pdbqt` format.\n\n    Raises:\n        FileNotFoundError: If the receptor file does not exist.\n        ValueError: If the file is not a supported format.\n    \"\"\"\n    self.file_path = Path(input).resolve()\n    self.cpu = _cpu\n\n    if not self.file_path.is_file():\n        raise FileNotFoundError(\n            f\"\u274c PDB file not found: {self.file_path}\")\n\n    if self.file_path.suffix.lower() not in [\".pdb\", \".pdbqt\"]:\n        raise ValueError(\n            \"\u274c Unsupported file format. Only '.pdb' and 'pdbqt' is supported.\")\n</code></pre>"},{"location":"api/pocket-finder/#docksuitex.pocket_finder.PocketFinder.run","title":"run","text":"<pre><code>run(\n    save_to: Union[str, Path] = None,\n) -&gt; List[\n    Dict[str, Union[int, Tuple[float, float, float]]]\n]\n</code></pre> <p>Execute P2Rank to predict ligand-binding pockets.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>Union[str, Path]</code> <p>Directory to save the P2Rank report.  Defaults to \".\".</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Union[int, Tuple[float, float, float]]]]</code> <p>List[Dict[str, Union[int, Tuple[float, float, float]]]]: A list of pocket predictions, where each dictionary contains: - <code>rank</code> (int): Pocket ranking by confidence. - <code>center</code> (tuple[float, float, float]): (x, y, z) coordinates of the pocket center.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If P2Rank fails to run.</p> Source code in <code>docksuitex\\pocket_finder.py</code> <pre><code>def run(self, save_to: Union[str, Path] = None) -&gt; List[Dict[str, Union[int, Tuple[float, float, float]]]]:\n    \"\"\"Execute P2Rank to predict ligand-binding pockets.\n\n    Args:\n        save_to (Union[str, Path], optional): Directory to save the P2Rank report. \n            Defaults to \".\".\n\n    Returns:\n        List[Dict[str, Union[int, Tuple[float, float, float]]]]:\n            A list of pocket predictions, where each dictionary contains:\n            - ``rank`` (int): Pocket ranking by confidence.\n            - ``center`` (tuple[float, float, float]): (x, y, z) coordinates of the pocket center.\n\n    Raises:\n        RuntimeError: If P2Rank fails to run.\n    \"\"\"\n\n    if save_to is None:\n        save_to = f\"./p2rank_results_{self.file_path.name.replace('.', '_')}\"\n\n    output_dir = Path(save_to).resolve()\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    cmd = [\n        str(P2RANK_PATH),\n        \"predict\",\n        \"-f\", str(self.file_path),\n        \"-o\", str(output_dir),\n        \"-threads\", str(self.cpu),  \n    ]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    if result.returncode != 0:\n        raise RuntimeError(f\"\u274c Error running P2Rank:\\n{result.stderr}\")\n\n    pockets = self._parse_output(output_dir)\n    print(f\"\u2705 Pocket prediction completed. Found {len(pockets)} pockets.\")\n    for i, pocket in enumerate(pockets):\n        print(f\"Pocket {i+1} center: {pocket['center']}\")\n    return pockets\n</code></pre>"},{"location":"api/protein/","title":"Protein","text":""},{"location":"api/protein/#docksuitex.protein.Protein","title":"docksuitex.protein.Protein","text":"<pre><code>Protein(\n    input: Union[str, Path],\n    fix_pdb: bool = True,\n    remove_heterogens: bool = True,\n    add_hydrogens: bool = True,\n    remove_water: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n)\n</code></pre> <p>Automated protein structure preparation for molecular docking.</p> <p>This class provides a complete workflow for preparing protein structures for docking simulations. It integrates PDBFixer for structure repair, Open Babel for format conversion, and AutoDockTools for PDBQT generation.</p> The preparation process handles <ul> <li>Format conversion from various structure formats to PDB</li> <li>Missing residue and atom reconstruction</li> <li>Nonstandard residue replacement</li> <li>Heteroatom and water molecule removal</li> <li>Hydrogen addition (polar or all)</li> <li>Gasteiger charge assignment</li> <li>PDBQT format conversion for docking</li> </ul> <p>Attributes:</p> Name Type Description <code>SUPPORTED_INPUTS</code> <code>set</code> <p>Supported input file formats.</p> <code>file_path</code> <code>Path</code> <p>Path to the input protein file.</p> <code>pdb_path</code> <code>Path | None</code> <p>Path to converted PDB file (if conversion needed).</p> <code>fixed_pdb_path</code> <code>Path | None</code> <p>Path to PDBFixer-processed PDB file.</p> <code>pdbqt_path</code> <code>Path | None</code> <p>Path to final PDBQT file (set after prepare()).</p> <code>fix_pdb</code> <code>bool</code> <p>Whether to fix structure with PDBFixer.</p> <code>remove_heterogens</code> <code>bool</code> <p>Whether to remove heteroatoms.</p> <code>add_hydrogens</code> <code>bool</code> <p>Whether to add hydrogen atoms.</p> <code>remove_water</code> <code>bool</code> <p>Whether to remove water molecules.</p> <code>add_charges</code> <code>bool</code> <p>Whether to assign Gasteiger charges.</p> <code>preserve_charge_types</code> <code>list[str] | None</code> <p>Atom types to preserve charges for.</p> Example <p>Standard protein preparation::</p> <pre><code>from docksuitex import Protein\n\nprotein = Protein(\"1abc.pdb\", fix_pdb=True)\npdbqt_file = protein.prepare(save_to=\"receptor.pdbqt\")\n</code></pre> <p>Preparation with metal ion charge preservation::</p> <pre><code>protein = Protein(\n    \"metalloprotein.pdb\",\n    preserve_charge_types=[\"Zn\", \"Fe\", \"Ca\"]\n)\npdbqt_file = protein.prepare()\n</code></pre> Note <p>Temporary files are created in a <code>temp/Proteins/</code> directory and are not automatically cleaned up. The final PDBQT file is saved to the specified location.</p> <p>Initialize a Protein object with a given file path and preparation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | Path</code> <p>Path to the protein input file.</p> required <code>fix_pdb</code> <code>bool</code> <p>Fix missing residues/atoms using PDBFixer. Defaults to True.</p> <code>True</code> <code>remove_heterogens</code> <code>bool</code> <p>Remove ligands/heterogens. Defaults to True.</p> <code>True</code> <code>add_hydrogens</code> <code>bool</code> <p>Add hydrogens. Defaults to True.</p> <code>True</code> <code>remove_water</code> <code>bool</code> <p>Remove water molecules. Defaults to True.</p> <code>True</code> <code>add_charges</code> <code>bool</code> <p>Assign Gasteiger charges. Defaults to True.</p> <code>True</code> <code>preserve_charge_types</code> <code>list[str]</code> <p>Atom types to preserve charges for. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the provided file does not exist.</p> <code>ValueError</code> <p>If the file format is not supported.</p> Source code in <code>docksuitex\\protein.py</code> <pre><code>def __init__(\n    self,\n    input: Union[str, Path],\n    fix_pdb: bool = True,\n    remove_heterogens: bool = True,\n    add_hydrogens: bool = True,\n    remove_water: bool = True,\n    add_charges: bool = True,\n    preserve_charge_types: Optional[list[str]] = None,\n):\n    \"\"\"Initialize a Protein object with a given file path and preparation parameters.\n\n    Args:\n        input (str | Path): Path to the protein input file.\n        fix_pdb (bool, optional): Fix missing residues/atoms using PDBFixer. Defaults to True.\n        remove_heterogens (bool, optional): Remove ligands/heterogens. Defaults to True.\n        add_hydrogens (bool, optional): Add hydrogens. Defaults to True.\n        remove_water (bool, optional): Remove water molecules. Defaults to True.\n        add_charges (bool, optional): Assign Gasteiger charges. Defaults to True.\n        preserve_charge_types (list[str], optional): Atom types to preserve charges for. Defaults to None.\n\n    Raises:\n        FileNotFoundError: If the provided file does not exist.\n        ValueError: If the file format is not supported.\n    \"\"\"\n    self.file_path = Path(input).resolve()\n    self.pdb_path: Optional[Path] = None\n    self.fixed_pdb_path: Optional[Path] = None\n    self.pdbqt_path: Optional[Path] = None\n\n    if not self.file_path.is_file():\n        raise FileNotFoundError(\n            f\"\u274c Protein file not found: {self.file_path}\")\n\n    self.ext = self.file_path.suffix.lower()\n    if self.ext not in self.SUPPORTED_INPUTS:\n        raise ValueError(\n            f\"\u274c Unsupported file format '{self.ext}'. Supported formats: {self.SUPPORTED_INPUTS}\")\n\n    # Store preparation parameters\n    self.fix_pdb = fix_pdb\n    self.remove_heterogens = remove_heterogens\n    self.add_hydrogens = add_hydrogens\n    self.remove_water = remove_water\n    self.add_charges = add_charges\n    self.preserve_charge_types = preserve_charge_types\n</code></pre>"},{"location":"api/protein/#docksuitex.protein.Protein.prepare","title":"prepare","text":"<pre><code>prepare(save_to: Union[str, Path] = '.') -&gt; Path\n</code></pre> <p>Handles protein preparation for docking using PDBFixer, Open Babel, and AutoDockTools (ADT). Saves the prepared PDBQT file to the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>str | Path</code> <p>Destination path for the PDBQT file. - If a directory: file will be saved with original name. - If a file path: saved with the given name. Defaults to current directory.</p> <code>'.'</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Path to the saved PDBQT file.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If Open Babel or AutoDockTools commands fail.</p> Source code in <code>docksuitex\\protein.py</code> <pre><code>def prepare(self, save_to: Union[str, Path] = \".\") -&gt; Path:\n    \"\"\"\n    Handles protein preparation for docking using PDBFixer, Open Babel, and AutoDockTools (ADT).\n    Saves the prepared PDBQT file to the specified location.\n\n    Args:\n        save_to (str | Path, optional): Destination path for the PDBQT file.\n            - If a directory: file will be saved with original name.\n            - If a file path: saved with the given name.\n            Defaults to current directory.\n\n    Returns:\n        Path: Path to the saved PDBQT file.\n\n    Raises:\n        RuntimeError: If Open Babel or AutoDockTools commands fail.\n    \"\"\"\n    # Create a unique temp directory per object\n    self.temp_dir = TEMP_DIR / \"Proteins\" / f\"{self.file_path.stem}_{uuid.uuid4().hex[:8]}\"\n    self.temp_dir.mkdir(parents=True, exist_ok=True)\n\n    # Convert to .pdb if needed\n    if self.ext != \".pdb\":\n        self.pdb_path = self.temp_dir / f\"{self.file_path.stem}.pdb\"\n        cmd = [str(OBABEL_EXE), str(self.file_path),\"-O\", str(self.pdb_path), \"--gen3d\"]\n        result = subprocess.run(cmd, capture_output=True, text=True)\n        if result.returncode != 0:\n            raise PreparationError(f\"Open Babel conversion failed:\\n{result.stderr}\")\n\n    else:\n        self.pdb_path = self.file_path\n\n    # Fix structure using PDBFixer\n    fixer = PDBFixer(filename=str(self.pdb_path))\n    if self.fix_pdb:\n        fixer.findMissingResidues()\n        fixer.findNonstandardResidues()\n        fixer.replaceNonstandardResidues()\n        fixer.findMissingAtoms()\n        fixer.addMissingAtoms()\n    if self.remove_heterogens:\n        fixer.removeHeterogens(keepWater=True)\n\n\n    # Save fixed PDB\n    fixed_pdb_path = self.temp_dir / f\"{self.file_path.stem}_fixed.pdb\"\n    with open(fixed_pdb_path, \"w\") as f:\n        PDBFile.writeFile(fixer.topology, fixer.positions, f)\n\n    self.fixed_pdb_path = fixed_pdb_path\n\n\n\n    # Convert to PDBQT using AutoDockTools\n    save_to = Path(save_to).expanduser().resolve()\n\n    # treat as file only if it has a suffix (e.g., .pdbqt)\n    if not save_to.suffix:\n        save_to = save_to / f\"{self.file_path.stem}.pdbqt\"\n\n    save_to.parent.mkdir(parents=True, exist_ok=True)\n\n    U_flag = \"nphs_lps_waters\" if self.remove_water else \"nphs_lps\"\n    cmd = [\n        str(MGL_PYTHON_EXE),\n        str(PREPARE_RECEPTOR_SCRIPT),\n        \"-r\", str(self.fixed_pdb_path),\n        \"-o\", str(save_to),\n        \"-U\", U_flag\n    ]\n    if self.add_hydrogens:\n        cmd += [\"-A\", \"hydrogens\"]\n\n    # Control charges\n    if not self.add_charges:\n        cmd += [\"-C\"]  # disable Gasteiger charges\n    elif self.preserve_charge_types:\n        for atom in self.preserve_charge_types:\n            cmd += [\"-p\", atom]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    if result.returncode != 0:\n        raise RuntimeError(f\"\u274c Error preparing PDBQT:\\n{result.stderr}\")\n\n    self.pdbqt_path = save_to\n\n    # # Save logic (merged from save_pdbqt)\n    # save_to = Path(save_to).expanduser().resolve()\n\n    # # treat as file only if it has a suffix (e.g., .pdbqt)\n    # if not save_to.suffix:\n    #     save_to = save_to / self.pdbqt_path.name\n\n    # save_to.parent.mkdir(parents=True, exist_ok=True)\n    # shutil.copy2(self.pdbqt_path, save_to)\n    print(f\"\u2705 Protein prepared successfully: {self.pdbqt_path}\")\n    return self.pdbqt_path\n</code></pre>"},{"location":"api/protein/#docksuitex.protein.Protein.view_molecule","title":"view_molecule","text":"<pre><code>view_molecule()\n</code></pre> <p>Visualize the protein structure in a Jupyter notebook.</p> <p>Uses NGLView to render either the prepared PDBQT file or the original input file in an interactive 3D viewer.</p> <p>Returns:</p> Type Description <p>nglview.NGLWidget: Interactive 3D molecular viewer widget.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If neither prepared nor input file exists.</p> <code>ImportError</code> <p>If nglview is not installed.</p> Note <p>This method requires a Jupyter Notebook/Lab environment and the nglview package.</p> Example <p>::</p> <pre><code>protein = Protein(\"protein.pdb\")\nprotein.prepare()\nprotein.view_molecule()  # Opens 3D viewer\n</code></pre> Source code in <code>docksuitex\\protein.py</code> <pre><code>def view_molecule(self):\n    \"\"\"Visualize the protein structure in a Jupyter notebook.\n\n    Uses NGLView to render either the prepared PDBQT file or the original\n    input file in an interactive 3D viewer.\n\n    Returns:\n        nglview.NGLWidget: Interactive 3D molecular viewer widget.\n\n    Raises:\n        FileNotFoundError: If neither prepared nor input file exists.\n        ImportError: If nglview is not installed.\n\n    Note:\n        This method requires a Jupyter Notebook/Lab environment and the\n        nglview package.\n\n    Example:\n        ::\n\n            protein = Protein(\"protein.pdb\")\n            protein.prepare()\n            protein.view_molecule()  # Opens 3D viewer\n    \"\"\"\n    path = Path(self.pdbqt_path if self.pdbqt_path else self.file_path).resolve()\n    return view_molecule(file_path=path)\n</code></pre>"},{"location":"api/viewer/","title":"Viewer","text":""},{"location":"api/viewer/#docksuitex.utils.viewer","title":"docksuitex.utils.viewer","text":"<p>3D molecular visualization using NGLView.</p> <p>This module provides functions for visualizing molecular structures and docking results in Jupyter Notebook environments using NGLView. It supports interactive 3D rendering of proteins, ligands, and docking poses.</p> The visualization functions handle <ul> <li>Single molecule rendering (proteins or ligands)</li> <li>Multi-pose docking result visualization with interactive controls</li> <li>Automatic pose navigation and animation</li> <li>Customizable representation styles</li> </ul> Example <p>Visualizing a single molecule::</p> <pre><code>from docksuitex.utils import view_molecule\n\n# View protein structure\nview_molecule(\"protein.pdb\")\n\n# View ligand\nview_molecule(\"ligand.mol2\")\n</code></pre> <p>Viewing docking results::</p> <pre><code>from docksuitex.utils import view_results\n\n# Interactive viewer with pose controls\nview_results(\n    protein_file=\"receptor.pdbqt\",\n    ligand_file=\"docked_output.pdbqt\"\n)\n</code></pre> Note <p>These functions require a Jupyter Notebook/Lab environment and the nglview package. They will not work in standard Python scripts.</p>"},{"location":"api/viewer/#docksuitex.utils.viewer.view_molecule","title":"view_molecule","text":"<pre><code>view_molecule(file_path: str | Path) -&gt; nv.NGLWidget\n</code></pre> <p>Renders a molecular structure in Jupyter Notebook using NGLView.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the molecular file (.pdb, .pdbqt, .mol2, or .sdf).</p> required <p>Returns:</p> Type Description <code>NGLWidget</code> <p>nv.NGLWidget: An NGLView widget.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified file does not exist.</p> Source code in <code>docksuitex\\utils\\viewer.py</code> <pre><code>def view_molecule(file_path: str | Path) -&gt; nv.NGLWidget:\n    \"\"\"\n    Renders a molecular structure in Jupyter Notebook using NGLView.\n\n    Args:\n        file_path (str): Path to the molecular file (.pdb, .pdbqt, .mol2, or .sdf).\n\n    Returns:\n        nv.NGLWidget: An NGLView widget.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n    \"\"\"\n    file_path = Path(file_path).resolve()\n    if not file_path.exists():\n        raise FileNotFoundError(f\"\u274c File not found: {file_path}\")\n\n    view = nv.show_file(str(file_path))   # replace with your protein file\n    return view\n</code></pre>"},{"location":"api/viewer/#docksuitex.utils.viewer.view_results","title":"view_results","text":"<pre><code>view_results(\n    protein_file: str | Path, ligand_file: str | Path\n) -&gt; None\n</code></pre> <p>Visualize docking results (multiple poses) of a ligand with a protein using NGLView and interactive Jupyter widgets.</p> Features <ul> <li>Step through individual docking poses.</li> <li>Toggle between showing one pose at a time or all poses simultaneously.</li> <li>Play/Pause automatic animation of poses.</li> <li>Adjust animation speed with a slider.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>protein_file</code> <code>str | Path</code> <p>Path to the receptor protein file (e.g., .pdb).</p> required <code>ligand_file</code> <code>str | Path</code> <p>Path to the ligand docking results file (.pdbqt). The file should contain multiple docking poses in MODEL/ENDMDL blocks.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Displays the visualization and interactive controls directly</p> <code>None</code> <p>in the Jupyter Notebook.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the protein or ligand file does not exist.</p> <code>ValueError</code> <p>If the ligand file does not contain valid MODEL/ENDMDL blocks.</p> Source code in <code>docksuitex\\utils\\viewer.py</code> <pre><code>def view_results(protein_file: str | Path, ligand_file: str | Path) -&gt; None:\n    \"\"\"\n    Visualize docking results (multiple poses) of a ligand with a protein\n    using NGLView and interactive Jupyter widgets.\n\n    Features:\n        - Step through individual docking poses.\n        - Toggle between showing one pose at a time or all poses simultaneously.\n        - Play/Pause automatic animation of poses.\n        - Adjust animation speed with a slider.\n\n    Args:\n        protein_file (str | Path): Path to the receptor protein file (e.g., .pdb).\n        ligand_file (str | Path): Path to the ligand docking results file (.pdbqt).\n            The file should contain multiple docking poses in MODEL/ENDMDL blocks.\n\n    Returns:\n        None: Displays the visualization and interactive controls directly\n        in the Jupyter Notebook.\n\n    Raises:\n        FileNotFoundError: If the protein or ligand file does not exist.\n        ValueError: If the ligand file does not contain valid MODEL/ENDMDL blocks.\n    \"\"\"\n    protein_file = str(Path(protein_file).resolve())\n    ligand_file = str(Path(ligand_file).resolve())\n\n    # Extract ligand poses into temp files\n    poses, current = [], 0\n    with open(ligand_file) as f:\n        pose = []\n        for line in f:\n            if line.startswith(\"MODEL\"):\n                pose = [line]\n            elif line.startswith(\"ENDMDL\"):\n                pose.append(line)\n                tmp = tempfile.NamedTemporaryFile(\n                    delete=False, suffix=\".pdbqt\", mode=\"w\")\n                tmp.write(\"\".join(pose))\n                tmp.close()\n                poses.append(tmp.name)\n            else:\n                pose.append(line)\n\n    playing, play_speed = [False], [1.0]\n\n    # NGL Viewer\n    view = nv.NGLWidget()\n    protein = view.add_component(protein_file)\n    protein.add_representation(\n        \"cartoon\", selection=\"protein\")\n\n    # Widgets\n    pose_label = widgets.Label()\n    show_all = widgets.ToggleButton(description=\"Show All Poses\")\n    play_btn = widgets.ToggleButton(description=\"Play\", icon=\"play\")\n    prev_btn = widgets.Button(description=\"\u25c0\ufe0f Prev\")\n    next_btn = widgets.Button(description=\"Next \u25b6\ufe0f\")\n    speed_slider = widgets.FloatSlider(\n        value=1.0, min=0.2, max=5, step=0.1, description=\"Speed:\")\n\n    # Track ligand components\n    ligand_components = []\n\n    def update(_=None):\n        # Remove old ligands\n        for lig in ligand_components:\n            try:\n                view.remove_component(lig)\n            except Exception:\n                pass\n        ligand_components.clear()\n\n        if show_all.value:\n            for lig in poses:\n                comp = view.add_component(lig)\n                comp.add_representation(\"ball+stick\")\n                ligand_components.append(comp)\n            pose_label.value = f\"All poses ({len(poses)})\"\n        else:\n            comp = view.add_component(poses[current])\n            comp.add_representation(\"ball+stick\")\n            ligand_components.append(comp)\n            pose_label.value = f\"Pose: {current+1}/{len(poses)}\"\n\n    def step(d):\n        nonlocal current\n        if not show_all.value:\n            current = (current + d) % len(poses)\n            update()\n\n    def toggle(change):\n        playing[0] = change[\"new\"]\n        play_btn.description, play_btn.icon = (\n            \"Pause\", \"pause\") if playing[0] else (\"Play\", \"play\")\n        if playing[0]:\n            threading.Thread(target=loop, daemon=True).start()\n\n    def loop():\n        while playing[0]:\n            time.sleep(1 / play_speed[0])\n            if not show_all.value:\n                step(1)\n\n    # Widget callbacks\n    show_all.observe(update, \"value\")\n    play_btn.observe(toggle, \"value\")\n    prev_btn.on_click(lambda _: step(-1))\n    next_btn.on_click(lambda _: step(1))\n    speed_slider.observe(\n        lambda c: play_speed.__setitem__(0, c[\"new\"]), \"value\")\n\n    # Initial update\n    update()\n\n    # Display\n    controls = widgets.VBox([\n        widgets.HBox([prev_btn, pose_label, next_btn]),\n        widgets.HBox([play_btn, speed_slider]),\n        show_all\n    ])\n    display(controls, view)\n</code></pre>"},{"location":"api/vina/","title":"VinaDocking","text":""},{"location":"api/vina/#docksuitex.vina.VinaDocking","title":"docksuitex.vina.VinaDocking","text":"<pre><code>VinaDocking(\n    receptor: Union[str, Path, Protein],\n    ligand: Union[str, Path, Ligand],\n    grid_center: tuple[float, float, float],\n    grid_size: tuple[int, int, int] = (20, 20, 20),\n    exhaustiveness: int = 8,\n    num_modes: int = 9,\n    verbosity: int = 1,\n    seed: Optional[int] = None,\n    _cpu: int = os.cpu_count() or 1,\n)\n</code></pre> <p>Python wrapper for AutoDock Vina molecular docking.</p> <p>This class provides a high-level interface to AutoDock Vina, handling parameter validation, command execution, result management, and visualization. It automates the docking workflow from input validation to result generation.</p> <p>The class validates input files, constructs appropriate command-line arguments, executes Vina, captures output, and organizes results in a structured directory.</p> <p>Attributes:</p> Name Type Description <code>receptor</code> <code>Path</code> <p>Path to the receptor PDBQT file.</p> <code>ligand</code> <code>Path</code> <p>Path to the ligand PDBQT file.</p> <code>grid_center</code> <code>tuple</code> <p>Grid box center coordinates (x, y, z) in Angstroms.</p> <code>grid_size</code> <code>tuple</code> <p>Grid box dimensions (x, y, z) in Angstroms.</p> <code>exhaustiveness</code> <code>int</code> <p>Search exhaustiveness parameter.</p> <code>num_modes</code> <code>int</code> <p>Maximum number of binding modes to generate.</p> <code>seed</code> <code>int | None</code> <p>Random seed for reproducibility.</p> <code>verbosity</code> <code>int</code> <p>Output verbosity level (0-2).</p> <code>output_dir</code> <code>Path</code> <p>Directory where results are saved (set after run()).</p> <code>output_pdbqt</code> <code>Path</code> <p>Path to docked poses file (set after run()).</p> <code>output_log</code> <code>Path</code> <p>Path to Vina log file (set after run()).</p> Example <p>Typical docking workflow::</p> <pre><code>from docksuitex import VinaDocking\n\n# Create docking instance\ndocking = VinaDocking(\n    receptor=\"prepared_receptor.pdbqt\",\n    ligand=\"prepared_ligand.pdbqt\",\n    grid_center=(25.0, 30.0, 15.0),\n    grid_size=(25, 25, 25),\n    exhaustiveness=16,\n    num_modes=20\n)\n\n# Execute docking\noutput_path = docking.run(save_to=\"vina_results\")\n\n# View results interactively\ndocking.view_results()\n</code></pre> Note <p>Grid center coordinates should be determined from binding pocket prediction (e.g., using PocketFinder) or known binding site information.</p> <p>Initialize a Vina docking job.</p> <p>Parameters:</p> Name Type Description Default <code>receptor</code> <code>Union[str, Path, Protein]</code> <p>Path to receptor PDBQT file. Must be a prepared protein structure in PDBQT format.</p> required <code>ligand</code> <code>Union[str, Path, Ligand]</code> <p>Path to ligand PDBQT file. Must be a prepared ligand structure in PDBQT format.</p> required <code>grid_center</code> <code>tuple[float, float, float]</code> <p>Grid box center coordinates (x, y, z) in Angstroms. Defines the center of the search space.</p> required <code>grid_size</code> <code>tuple[int, int, int]</code> <p>Grid box dimensions (x, y, z) in Angstroms. Defines the size of the search space. Defaults to (20, 20, 20).</p> <code>(20, 20, 20)</code> <code>exhaustiveness</code> <code>int</code> <p>Search exhaustiveness parameter. Higher values increase accuracy but also computation time. Typical range: 1-32. Defaults to 8.</p> <code>8</code> <code>num_modes</code> <code>int</code> <p>Maximum number of binding modes to generate. Vina will output up to this many poses ranked by predicted affinity. Defaults to 9.</p> <code>9</code> <code>verbosity</code> <code>int</code> <p>Output verbosity level. 0 = quiet, 1 = normal, 2 = verbose. Defaults to 1.</p> <code>1</code> <code>seed</code> <code>Optional[int]</code> <p>Random seed for reproducibility. If None, Vina uses a random seed. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If receptor or ligand file does not exist.</p> <code>ValueError</code> <p>If input files are not PDBQT format or grid parameters are invalid (wrong tuple size or non-numeric values).</p> <code>TypeError</code> <p>If grid_center or grid_size contain non-numeric values.</p> Source code in <code>docksuitex\\vina.py</code> <pre><code>def __init__(\n    self,\n    receptor: Union[str, Path, \"Protein\"],\n    ligand: Union[str, Path, \"Ligand\"],\n    grid_center: tuple[float, float, float],\n    grid_size: tuple[int, int, int] = (20, 20, 20),\n    exhaustiveness: int = 8,\n    num_modes: int = 9,\n    verbosity: int = 1,\n    seed: Optional[int] = None,\n\n    _cpu: int = os.cpu_count() or 1,\n):\n    \"\"\"Initialize a Vina docking job.\n\n    Args:\n        receptor (Union[str, Path, Protein]): Path to receptor PDBQT file.\n            Must be a prepared protein structure in PDBQT format.\n        ligand (Union[str, Path, Ligand]): Path to ligand PDBQT file.\n            Must be a prepared ligand structure in PDBQT format.\n        grid_center (tuple[float, float, float]): Grid box center coordinates\n            (x, y, z) in Angstroms. Defines the center of the search space.\n        grid_size (tuple[int, int, int], optional): Grid box dimensions\n            (x, y, z) in Angstroms. Defines the size of the search space.\n            Defaults to (20, 20, 20).\n        exhaustiveness (int, optional): Search exhaustiveness parameter.\n            Higher values increase accuracy but also computation time.\n            Typical range: 1-32. Defaults to 8.\n        num_modes (int, optional): Maximum number of binding modes to generate.\n            Vina will output up to this many poses ranked by predicted affinity.\n            Defaults to 9.\n        verbosity (int, optional): Output verbosity level.\n            0 = quiet, 1 = normal, 2 = verbose. Defaults to 1.\n        seed (Optional[int], optional): Random seed for reproducibility.\n            If None, Vina uses a random seed. Defaults to None.\n\n    Raises:\n        FileNotFoundError: If receptor or ligand file does not exist.\n        ValueError: If input files are not PDBQT format or grid parameters\n            are invalid (wrong tuple size or non-numeric values).\n        TypeError: If grid_center or grid_size contain non-numeric values.\n    \"\"\"\n\n    self.receptor = Path(receptor).resolve()\n    self.ligand = Path(ligand).resolve()\n\n    if not self.receptor.is_file():\n        raise FileNotFoundError(\n            f\"\u274c Receptor file not found: {self.receptor}\")\n    if not self.ligand.is_file():\n        raise FileNotFoundError(f\"\u274c Ligand file not found: {self.ligand}\")\n\n    if self.receptor.suffix.lower() != \".pdbqt\":\n        raise ValueError(\"\u26a0\ufe0f Receptor must be a .pdbqt file.\")\n    if self.ligand.suffix.lower() != \".pdbqt\":\n        raise ValueError(\"\u26a0\ufe0f Ligand must be a .pdbqt file.\")\n\n    if not (isinstance(grid_center, tuple) and len(grid_center) == 3):\n        raise ValueError(\"\u26a0\ufe0f 'grid_center' must be a 3-tuple of floats.\")\n    if not (isinstance(grid_size, tuple) and len(grid_size) == 3):\n        raise ValueError(\"\u26a0\ufe0f 'grid_size' must be a 3-tuple of floats.\")\n    if any(not isinstance(v, (float, int)) for v in grid_center + grid_size):\n        raise TypeError(\n            \"\u26a0\ufe0f Grid grid_center and grid_size values must be float or int.\")\n\n    self.grid_center = grid_center\n    self.grid_size = grid_size\n    self.exhaustiveness = exhaustiveness\n    self.num_modes = num_modes\n    self.cpu = _cpu\n    self.seed = seed\n    self.verbosity = verbosity\n</code></pre>"},{"location":"api/vina/#docksuitex.vina.VinaDocking.run","title":"run","text":"<pre><code>run(save_to: Union[str, Path] = None) -&gt; Path\n</code></pre> <p>Execute AutoDock Vina docking simulation.</p> <p>Runs the Vina docking calculation with the configured parameters, saves results to the specified directory, and generates output files including docked poses and a log file with binding energies.</p> <p>The method copies input files to the output directory, constructs the Vina command line, executes the docking, and validates the results.</p> <p>Parameters:</p> Name Type Description Default <code>save_to</code> <code>Union[str, Path]</code> <p>Directory path where docking results will be saved. If None, creates a directory named \"vina_docked_{receptor}_{ligand}\" in the current directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Absolute path to the output directory containing: - Receptor and ligand PDBQT files (copies of inputs) - output.pdbqt: Docked ligand poses ranked by affinity - log.txt: Vina output log with binding energies and RMSD values</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If Vina execution fails (non-zero return code) or if expected output files (output.pdbqt, log.txt) are not created.</p> Example <p>::</p> <pre><code>docking = VinaDocking(\n    receptor=\"protein.pdbqt\",\n    ligand=\"ligand.pdbqt\",\n    grid_center=(10.0, 15.0, 20.0)\n)\nresults_path = docking.run(save_to=\"my_results\")\nprint(f\"Results saved to: {results_path}\")\n</code></pre> Source code in <code>docksuitex\\vina.py</code> <pre><code>def run(self, save_to: Union[str, Path] = None) -&gt; Path:\n    \"\"\"Execute AutoDock Vina docking simulation.\n\n    Runs the Vina docking calculation with the configured parameters,\n    saves results to the specified directory, and generates output files\n    including docked poses and a log file with binding energies.\n\n    The method copies input files to the output directory, constructs the\n    Vina command line, executes the docking, and validates the results.\n\n    Args:\n        save_to (Union[str, Path], optional): Directory path where docking\n            results will be saved. If None, creates a directory named\n            \"vina_docked_{receptor}_{ligand}\" in the current directory.\n            Defaults to None.\n\n    Returns:\n        Path: Absolute path to the output directory containing:\n            - Receptor and ligand PDBQT files (copies of inputs)\n            - output.pdbqt: Docked ligand poses ranked by affinity\n            - log.txt: Vina output log with binding energies and RMSD values\n\n    Raises:\n        RuntimeError: If Vina execution fails (non-zero return code) or\n            if expected output files (output.pdbqt, log.txt) are not created.\n\n    Example:\n        ::\n\n            docking = VinaDocking(\n                receptor=\"protein.pdbqt\",\n                ligand=\"ligand.pdbqt\",\n                grid_center=(10.0, 15.0, 20.0)\n            )\n            results_path = docking.run(save_to=\"my_results\")\n            print(f\"Results saved to: {results_path}\")\n    \"\"\"\n\n    if save_to is None:\n        save_to = f\"vina_docked_{self.receptor.stem}_{self.ligand.stem}\"\n    self.output_dir = Path(save_to).resolve()\n    self.output_dir.mkdir(parents=True, exist_ok=True)\n\n    shutil.copy2(self.receptor, self.output_dir / self.receptor.name)\n    shutil.copy2(self.ligand, self.output_dir / self.ligand.name)\n\n    self.receptor = self.output_dir / self.receptor.name\n    self.ligand = self.output_dir / self.ligand.name\n\n    # Output files\n    self.output_pdbqt = self.output_dir / f\"output.pdbqt\"\n    self.output_log = self.output_dir / f\"log.txt\"\n\n    self._vina_output: Optional[str] = None\n\n    cmd = [\n        str(VINA_PATH),\n        \"--receptor\", str(self.receptor),\n        \"--ligand\", str(self.ligand),\n        \"--center_x\", str(self.grid_center[0]),\n        \"--center_y\", str(self.grid_center[1]),\n        \"--center_z\", str(self.grid_center[2]),\n        \"--size_x\", str(self.grid_size[0]),\n        \"--size_y\", str(self.grid_size[1]),\n        \"--size_z\", str(self.grid_size[2]),\n        \"--out\", str(self.output_pdbqt),\n        \"--exhaustiveness\", str(self.exhaustiveness),\n        \"--num_modes\", str(self.num_modes),\n        \"--cpu\", str(self.cpu),\n        \"--verbosity\", str(self.verbosity),\n    ]\n\n    if self.seed is not None:\n        cmd += [\"--seed\", str(self.seed)]\n\n    result = subprocess.run(cmd, capture_output=True, text=True)\n    if result.returncode != 0:\n        raise RuntimeError(f\"\u274c Error running AutoDock Vina:\\n{result.stderr}\")\n\n    self._vina_output = result.stdout\n\n    if self._vina_output:\n        with open(self.output_log, \"w\") as log_file:\n            log_file.write(self._vina_output)\n\n    # Check if results exist before proceeding\n    if not self.output_pdbqt.exists() or not self.output_log.exists():\n        raise RuntimeError(\n            \"\u274c Docking results are missing. Check log.txt for details.\"\n        )\n\n    print(f\"\u2705 Vina docking completed. Results saved to: {self.output_dir}\")\n    return self.output_dir\n</code></pre>"},{"location":"api/vina/#docksuitex.vina.VinaDocking.view_results","title":"view_results","text":"<pre><code>view_results()\n</code></pre> <p>Visualize docking results using NGLView in Jupyter Notebook.</p> <p>Creates an interactive 3D visualization of the receptor-ligand complex with controls to browse through different docking poses. This method requires a Jupyter Notebook environment and the nglview package.</p> The visualization includes <ul> <li>Receptor structure displayed as cartoon representation</li> <li>Ligand poses displayed as ball-and-stick models</li> <li>Interactive controls to step through poses</li> <li>Play/pause animation of poses</li> <li>Speed control slider</li> </ul> <p>Returns:</p> Name Type Description <code>None</code> <p>Displays the interactive widget directly in the notebook.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If run() has not been called yet (output files not set).</p> <code>FileNotFoundError</code> <p>If output files have been deleted or moved.</p> <code>ImportError</code> <p>If nglview is not installed.</p> Note <p>This method must be called after run() to ensure output files exist. It only works in Jupyter Notebook/Lab environments.</p> Example <p>::</p> <pre><code>docking = VinaDocking(\n    receptor=\"protein.pdbqt\",\n    ligand=\"ligand.pdbqt\",\n    grid_center=(10.0, 15.0, 20.0)\n)\ndocking.run()\ndocking.view_results()  # Opens interactive 3D viewer\n</code></pre> Source code in <code>docksuitex\\vina.py</code> <pre><code>def view_results(self):\n    \"\"\"Visualize docking results using NGLView in Jupyter Notebook.\n\n    Creates an interactive 3D visualization of the receptor-ligand complex\n    with controls to browse through different docking poses. This method\n    requires a Jupyter Notebook environment and the nglview package.\n\n    The visualization includes:\n        - Receptor structure displayed as cartoon representation\n        - Ligand poses displayed as ball-and-stick models\n        - Interactive controls to step through poses\n        - Play/pause animation of poses\n        - Speed control slider\n\n    Returns:\n        None: Displays the interactive widget directly in the notebook.\n\n    Raises:\n        AttributeError: If run() has not been called yet (output files not set).\n        FileNotFoundError: If output files have been deleted or moved.\n        ImportError: If nglview is not installed.\n\n    Note:\n        This method must be called after run() to ensure output files exist.\n        It only works in Jupyter Notebook/Lab environments.\n\n    Example:\n        ::\n\n            docking = VinaDocking(\n                receptor=\"protein.pdbqt\",\n                ligand=\"ligand.pdbqt\",\n                grid_center=(10.0, 15.0, 20.0)\n            )\n            docking.run()\n            docking.view_results()  # Opens interactive 3D viewer\n    \"\"\"\n    view_results(protein_file=self.receptor, ligand_file=self.output_pdbqt)\n</code></pre>"},{"location":"getting-started/examples/","title":"Examples","text":"<p>Here are some examples of how to use DockSuiteX.</p>"},{"location":"getting-started/examples/#batch-docking","title":"Batch Docking","text":"<pre><code>from docksuitex.batch_docking import BatchVinaDocking\n\nbatch = BatchVinaDocking(\n    receptors_with_centers={\"prot.pdbqt\": [(0,0,0)]},\n    ligands=[\"lig1.pdbqt\", \"lig2.pdbqt\"]\n)\nbatch.run_all()\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.8 or higher</li> <li>Operating System: Windows (currently Windows-only)</li> <li>Dependencies: Automatically installed via pip</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install docksuitex\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<pre><code>git clone https://github.com/MangalamGSinha/DockSuiteX.git\ncd DockSuiteX\npip install .\n</code></pre>"},{"location":"getting-started/installation/#binary-dependencies","title":"Binary Dependencies","text":"<p>DockSuiteX automatically downloads required binary executables on first import:</p> <ul> <li>MGLTools (AutoDockTools)</li> <li>AutoDock Vina</li> <li>AutoDock4 &amp; AutoGrid</li> <li>P2Rank</li> <li>Open Babel</li> </ul> <p>The binaries are downloaded from the GitHub repository and extracted to the package's <code>bin/</code> directory.</p> <p>If binary download fails, you can manually download from: <pre><code>https://github.com/MangalamGSinha/DockSuiteX_Binaries\n</code></pre></p> <p>Extract to: <code>&lt;package_location&gt;/docksuitex/bin/</code></p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with DockSuiteX quickly.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<pre><code>from docksuitex import VinaDocking\n\n# Initialize docking\ndocking = VinaDocking(\n    receptor=\"protein.pdbqt\",\n    ligand=\"ligand.pdbqt\",\n    grid_center=(0, 0, 0)\n)\n\n# Run docking\nresults = docking.run()\n</code></pre>"}]}